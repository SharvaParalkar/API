<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FilamentBros Order Dashboard</title>
  <!-- Load Socket.IO client from CDN as backup -->
  <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
  <!-- Load local Socket.IO client as primary -->
  <script src="/socket.io/socket.io.js"></script>
  <style>
    body {
      font-family: "Roboto", sans-serif;
      margin: 0;
      padding: 2rem;
      background-color: #f5f5f5;
    }

    h1 {
      text-align: center;
      color: #1f6463;
      margin-bottom: 1rem;
    }

    .search-container {
      max-width: 700px;
      margin-left: auto;
      margin-right: auto;
      margin-bottom: 2rem;
      display: flex;
      gap: 1rem;
      align-items: center;
      justify-content: center;
      width: 100%;
      padding: 0 1rem;
    }

    .search-container input {
      width: 100%;
      max-width: 700px;
      flex: 1;
      padding: 0.75rem;
      font-size: 1rem;
      border: 2px solid #ccc;
      border-radius: 5rem;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 1.5rem;
      align-items: start;
    }

    .card {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      background: white;
      border-radius: 1rem;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      padding: 1.25rem;
      color: #333;
      position: relative;
      height: auto;
    }

    .card h2 {
      font-size: 1.2rem;
      margin-bottom: 1rem;
      color: #1f6463;
      margin: 0 0 0.75rem 0;
    }

    .card ul {
      padding-left: 1rem;
      margin: 0;
      font-size: 0.95rem;
      list-style: disc;
    }

    .card:hover {
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.15);
      transform: translateY(-3px);
      transition: 0.2s ease;
    }

    .card ul li {
      margin-bottom: 0.5rem;
    }

    .order-id {
      margin-top: 1.25rem;
      padding-top: 0.75rem;
      border-top: 1px solid #ddd;
      text-align: center;
      font-size: 0.8rem;
      color: #666;
      font-weight: bold;
    }

    .stl-header {
      font-weight: bold;
      margin-top: 1rem;
      margin-bottom: 0.5rem;
    }

    .stl-list {
      padding-left: 1.2rem;
      list-style-type: disc;
      margin-top: 0;
      margin-bottom: 0.75rem;
    }

    .stl-list li {
      font-size: 0.9rem;
      margin-bottom: 0.35rem;
    }

    .stl-link {
      display: block;
      max-width: 100%;
      color: #1f6463;
      text-decoration: none;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: normal;
      word-break: break-word;
      /* Ensures long words break cleanly */
    }

    .download-all-btn {
      margin-top: 0.25rem;
      display: inline-block;
      margin-top: 0.5rem;
      padding: 0.4rem 0.75rem;
      background-color: #1f6463;
      color: white;
      text-decoration: none;
      border-radius: 6px;
      font-size: 0.85rem;
    }

    .status-submitted {
      background-color: #1f6463;
    }

    .status-complete {
      background-color: #5cb85c;
    }

    .status-failed {
      background-color: #d9534f;
    }

    .details-toggle {
      margin-top: 0.5rem;
      font-size: 0.85rem;
      color: #1f6463;
      background: none;
      border: none;
      font-weight: bold;
      cursor: pointer;
    }

    .details-section {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.6s ease, opacity 0.6s ease;
      opacity: 0;
      margin-top: 0;
    }

    .details-section.visible {
      max-height: 1000px;
      /* large enough to cover any content height */
      opacity: 1;
      margin-top: 0.75rem;
    }

    .details-table {
      width: 100%;
      font-size: 0.9rem;
      border-spacing: 0.4rem 0.25rem;
    }

    .details-table td {
      vertical-align: top;
      padding: 0.2rem 0.5rem;
    }

    .details-table td:first-child {
      font-weight: bold;
      width: 30%;
    }

    .status-dropdown {
      padding: 0.4rem 0.75rem;
      border-radius: 0.5rem;
      border: 1px solid #ccc;
      font-size: 0.9rem;
      background-color: #f5f5f5;
    }

    .status-pending {
      background-color: #ff6e5f;
      color: #000;
    }

    .status-pre-print {
      background-color: #ffaea5;
      color: #000;
    }

    .status-printing {
      background-color: #f4d03f;
      color: #000;
    }

    .status-printing-pay-later {
      background-color: #f4d03f;
      color: #000;
    }

    .status-completed {
      background-color: #2ecc71;
      color: #000;
    }

    .toggle-wrapper {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
      flex-shrink: 0;
    }

    .toggle-wrapper input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: 0.3s;
      border-radius: 24px;
    }

    .slider::before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }

    .toggle-wrapper input:checked+.slider {
      background-color: #1f6463;
    }

    .toggle-wrapper input:checked+.slider::before {
      transform: translateX(20px);
    }

    .toggle-label {
      font-size: 0.9rem;
      margin-left: 0.5rem;
      line-height: 24px;
      color: #333;
    }

    .top-bar {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 2rem;
      flex-direction: column;
    }

    .toggle-group {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .login-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: white;
      z-index: 9999;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .login-box {
      background: white;
      padding: 2rem;
      border-radius: 1rem;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
      width: 100%;
      max-width: 360px;
      text-align: center;

      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .login-box input[type="text"],
    .login-box input[type="password"] {
      width: 100%;
      padding: 0.75rem;
      margin-bottom: 1rem;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 0.5rem;
      box-sizing: border-box;
      /* ‚úÖ prevents padding from adding to width */
    }

    .login-box button {
      width: 100%;
      padding: 0.75rem;
      font-size: 1rem;
      background-color: #1f6463;
      color: white;
      border: none;
      border-radius: 0.5rem;
      cursor: pointer;
    }

    .login-box .remember-line {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      font-size: 0.9rem;
      margin-bottom: 1rem;
      justify-content: left;
    }

    .toggles-wrapper {
      display: flex;
      gap: 1rem;
    }

    .search-input-wrapper {
      flex-grow: 1;
      max-width: 700px;
      margin: 0 auto;
    }

    .search-bar-wrapper {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 2rem;
      height: 3.5rem;
    }

    .toggles-wrapper {
      position: absolute;
      left: 0;
      display: flex;
      gap: 1rem;
      align-items: center;
      padding-left: 1rem;
    }

    .centered-search {
      max-width: 700px;
      width: 100%;
      padding: 0.75rem;
      font-size: 1rem;
      border: 2px solid #ccc;
      border-radius: 5rem;
    }

    .search-bar-flex {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
      margin-bottom: 2rem;
      width: 100%;
      max-width: 800px;
      /* cap total width */
      margin-left: auto;
      margin-right: auto;
    }

    .left-toggles {
      display: flex;
      gap: 1rem;
      align-items: center;
      flex-shrink: 0;
    }

    .center-search {
      flex-grow: 1;
      max-width: 700px;
      display: flex;
      justify-content: center;
    }

    .center-search input {
      width: 100%;
      max-width: 700px;
      padding: 0.75rem;
      font-size: 1rem;
      border: 2px solid #ccc;
      border-radius: 5rem;
    }
  </style>
</head>

<body>
  <h1>FilamentBros Order Dashboard</h1>

  <div style="display: flex; justify-content: center; gap: 1rem; margin-bottom: 1rem;">
    <button id="tabAll"
      style="padding: 0.6rem 1rem; border-radius: 1rem; background: #1f6463; color: white; border: none;">All
      Orders</button>
    <button id="tabClaimed"
      style="padding: 0.6rem 1rem; border-radius: 1rem; background: #ccc; color: black; border: none;">Claimed
      Orders</button>
  </div>

  <div class="top-bar">
    <div class="search-bar-flex">
      <div class="left-toggles">
        <div class="toggle-group">
          <span class="toggle-label">Old Orders</span>
          <label class="toggle-wrapper">
            <input type="checkbox" id="showOldToggle" />
            <span class="slider"></span>
          </label>
        </div>

        <div class="toggle-group">
          <span class="toggle-label">Completed</span>
          <label class="toggle-wrapper">
            <input type="checkbox" id="showCompletedToggle" />
            <span class="slider"></span>
          </label>
        </div>
      </div>

      <div class="center-search">
        <input type="text" id="searchInput" placeholder="Search by name, email, phone, or order ID..." />
      </div>
    </div>
  </div>


  <div class="grid" id="orderGrid"></div>

  <script>
    // Verify Socket.IO is loaded
    if (typeof io === 'undefined') {
      console.error('‚ùå Socket.IO client failed to load');
      // Try to reload the script
      const script = document.createElement('script');
      script.src = 'https://cdn.socket.io/4.7.4/socket.io.min.js';
      script.onload = () => {
        console.log('‚úÖ Socket.IO client loaded from CDN');
        initialize();
      };
      script.onerror = () => {
        console.error('‚ùå Failed to load Socket.IO client from CDN');
      };
      document.head.appendChild(script);
    } else {
      console.log('‚úÖ Socket.IO client loaded successfully');
    }

    // Constants
    const REFRESH_INTERVAL = 10000; // 10 seconds
    const SEARCH_DEBOUNCE = 200; // 200ms
    const MAX_RETRY_ATTEMPTS = 3;

    // State management
    const state = {
      allOrders: [],
      currentUser: null,
      currentTab: "all",
      socket: null,
      retryCount: 0,
      filters: {
        showOld: false,
        showCompleted: false
      }
    };

    // Socket.IO setup with better error handling
    const socket = io({
      path: '/socket.io/',
      transports: ['websocket', 'polling'],
      autoConnect: false,
      reconnection: true,
      reconnectionAttempts: Infinity,
      reconnectionDelay: 1000,
      reconnectionDelayMax: 5000,
      timeout: 20000,
      withCredentials: true,
      forceNew: true,
      rejectUnauthorized: false
    });

    socket.on('connect_error', (error) => {
      console.error('‚ùå WebSocket connection error:', error);
      console.log('üîç Connection details:', {
        protocol: window.location.protocol,
        host: window.location.host,
        hostname: window.location.hostname,
        port: window.location.port,
        readyState: socket.connected ? 'connected' : 'disconnected',
        transport: socket.io.engine.transport.name
      });
      
      // Try to reconnect with polling if websocket fails
      if (socket.io.engine.transport.name === 'websocket') {
        console.log('‚ö†Ô∏è WebSocket failed, falling back to polling...');
        socket.io.engine.transport.name = 'polling';
        socket.connect();
      }
    });

    socket.on('connect', () => {
      console.log('‚úÖ WebSocket connected');
      state.socket = socket;
    });

    socket.on('disconnect', (reason) => {
      console.log('üîå WebSocket disconnected:', reason);
    });

    socket.on('order-updated', (data) => {
      console.log('üì• Received order update:', data);
      handleOrderUpdate(data);
    });

    // Handle incoming order updates
    function handleOrderUpdate(updatedOrder) {
      console.log('üîÑ Processing order update:', updatedOrder);

      // Update order in state
      const index = state.allOrders.findIndex(order => order.id === updatedOrder.id);
      if (index !== -1) {
        state.allOrders[index] = updatedOrder;
      } else {
        // If the order isn't in our state, check if it should be based on current filters
        const shouldInclude = shouldShowOrder(updatedOrder);
        if (shouldInclude) {
          state.allOrders.unshift(updatedOrder);
        }
      }

      // Update UI if the order is currently visible
      const orderCard = document.querySelector(`[data-order-id="${updatedOrder.id}"]`);
      if (orderCard) {
        // Update status dropdown
        const statusDropdown = orderCard.querySelector('.status-dropdown');
        if (statusDropdown) {
          statusDropdown.value = updatedOrder.status || 'pending';
          applyStatusColor(statusDropdown, updatedOrder.status || 'pending');
        }

        // Update other card elements
        updateCardElements(orderCard, updatedOrder);
      } else {
        // If the card isn't visible but should be, reapply current filters
        const query = document.getElementById("searchInput").value;
        filterOrders(query);
      }
    }

    // Helper function to check if an order should be shown based on current filters
    function shouldShowOrder(order) {
      const showOld = document.getElementById("showOldToggle").checked;
      const showCompleted = document.getElementById("showCompletedToggle").checked;
      
      // Check completed status
      if (!showCompleted && order.status?.toLowerCase() === 'completed') {
        return false;
      }

      // Check age
      if (!showOld) {
        const oneWeekAgo = new Date();
        oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
        const orderDate = new Date(order.submitted_at);
        if (orderDate < oneWeekAgo) {
          return false;
        }
      }

      return true;
    }

    // Helper function to update card elements
    function updateCardElements(card, order) {
      // Update price
      const priceElement = card.querySelector('p');
      if (priceElement) {
        priceElement.innerHTML = `<strong>Est. Price:</strong> ${
          order.est_price ? `$${order.est_price.toFixed(2)}` : '‚Äî'
        }`;
      }

      // Update notes if visible
      const detailsSection = card.querySelector('.details-section');
      if (detailsSection?.classList.contains('visible')) {
        const notesElement = detailsSection.querySelector('td:contains("Staff Notes:")');
        if (notesElement?.nextElementSibling) {
          notesElement.nextElementSibling.textContent = order.order_notes || '‚Äî';
        }
      }
    }

    // Utility functions
    const debounce = (func, wait) => {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    };

    const handleError = async (err, operation) => {
      console.error(`‚ùå Error during ${operation}:`, err);
      
      if (err.status === 401) {
        clearAllIntervals();
        showLoginOverlay();
        return;
      }

      if (state.retryCount < MAX_RETRY_ATTEMPTS) {
        state.retryCount++;
        await new Promise(resolve => setTimeout(resolve, 1000 * state.retryCount));
        return true; // Retry
      }
      
      state.retryCount = 0;
      return false; // Don't retry
    };

    const clearAllIntervals = () => {
      state.intervals.forEach(clearInterval);
      state.intervals = [];
    };

    // API functions
    const api = {
      async fetchOrders() {
        try {
          // Get current filter states
          const showOld = document.getElementById("showOldToggle").checked;
          const showCompleted = document.getElementById("showCompletedToggle").checked;
          
          // Build query string
          const params = new URLSearchParams({
            showOld: showOld.toString(),
            showCompleted: showCompleted.toString()
          });
          
          const url = `/dashboard/data?${params.toString()}`;
          console.log('üîç Fetching orders with filters:', { showOld, showCompleted });
          
          const res = await fetch(url, { credentials: 'include' });
          if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
          
          const data = await res.json();
          console.log(`üì¶ Received ${data.length} orders`);
          return data;
        } catch (err) {
          console.error('‚ùå Failed to fetch orders:', err);
          return [];
        }
      },

      async updateStatus(orderId, status) {
        try {
          const res = await fetch("/dashboard/update-status", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ orderId, status }),
          });
          if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
          return await res.json();
        } catch (err) {
          await handleError(err, 'updateStatus');
          throw err;
        }
      },

      // Add other API functions here...
    };

    // UI update functions
    const ui = {
      updateTabStyles() {
        const allTab = document.getElementById("tabAll");
        const claimedTab = document.getElementById("tabClaimed");
        
        allTab.style.backgroundColor = state.currentTab === "all" ? "#1f6463" : "#ccc";
        allTab.style.color = state.currentTab === "all" ? "white" : "black";
        claimedTab.style.backgroundColor = state.currentTab === "claimed" ? "#1f6463" : "#ccc";
        claimedTab.style.color = state.currentTab === "claimed" ? "white" : "black";
      },

      showLoginOverlay() {
        const overlay = document.getElementById("loginOverlay");
        if (overlay) overlay.style.display = "flex";
      },

      hideLoginOverlay() {
        const overlay = document.getElementById("loginOverlay");
        if (overlay) overlay.style.display = "none";
      }
    };

    // Event handlers
    const handlers = {
      async onStatusChange(event, orderId) {
        const newStatus = event.target.value;
        const previousValue = event.target.dataset.previousValue;
        
        try {
          // Update UI immediately
          applyStatusColor(event.target, newStatus);
          event.target.dataset.previousValue = newStatus;
          
          console.log(`üîÑ Initiating status change for ${orderId}: ${newStatus}`);
          
          // Emit via WebSocket first
          socket.emit('status-update', { orderId, status });
          
          // Backup HTTP request
          const response = await api.updateStatus(orderId, newStatus);
          console.log('‚úÖ HTTP update response:', response);
          
        } catch (err) {
          console.error(`‚ùå Failed to update status:`, err);
          // Revert on error
          event.target.value = previousValue;
          applyStatusColor(event.target, previousValue);
          event.target.dataset.previousValue = previousValue;
        }
      },

      onTabClick(tab) {
        state.currentTab = tab;
        ui.updateTabStyles();
        filterOrders(document.getElementById("searchInput").value);
      },

      onSearchInput: debounce((event) => {
        filterOrders(event.target.value);
      }, SEARCH_DEBOUNCE)
    };

    // Initialize
    async function initialize() {
      try {
        console.log('üöÄ Initializing dashboard...');
        
        // Check for remembered login
        if (localStorage.getItem("rememberedUser")) {
          const res = await fetch("/dashboard/whoami", { credentials: "include" });
          if (res.ok) {
            const data = await res.json();
            state.currentUser = data.username;
            ui.hideLoginOverlay();
            console.log('üë§ Logged in as:', state.currentUser);
            
            // Initialize WebSocket first
            socket.connect();
            
            // Then load orders
            await loadInitialOrders();
          } else {
            localStorage.removeItem("rememberedUser");
            console.log('‚ùå Remembered login invalid');
          }
        }

        // Setup event listeners
        document.getElementById("searchInput").addEventListener("input", handlers.onSearchInput);
        document.getElementById("tabAll").addEventListener("click", () => handlers.onTabClick("all"));
        document.getElementById("tabClaimed").addEventListener("click", () => handlers.onTabClick("claimed"));
        
        // Add socket reconnection on visibility change
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible') {
            if (!state.socket?.connected) {
              console.log('üîÑ Page became visible, reconnecting socket');
              socket.connect();
            }
          }
        });

        console.log('‚úÖ Dashboard initialized successfully');
      } catch (err) {
        console.error('‚ùå Failed to initialize dashboard:', err);
        await handleError(err, 'initialization');
      }
    }

    // Start the app
    document.addEventListener("DOMContentLoaded", initialize);

    let allOrders = [];
    const VALID_STATUSES = [
      "pending",
      "pre print",
      "printing",
      "printing pay later",
      "completed",
    ];

    let currentUser = null;
    let currentTab = "all"; // "all" or "claimed"


    async function renderOrders(
      orders,
      expandDetails = false,
      container = null
    ) {
      const grid = container || document.getElementById("orderGrid");
      if (!container) grid.innerHTML = "";
      for (const order of orders) {
        const card = document.createElement("div");
        card.className = "card";
        card.dataset.orderId = order.id; // Add order ID to card

        const heading = document.createElement("h2");
        heading.textContent = order.name || "Unnamed Order";
        card.appendChild(heading); // Only append ONCE

        const statusOptions = [
          "pending",
          "pre print",
          "printing",
          "printing pay later", // üîÅ fix casing here
          "completed",
        ];
        const currentStatus = (order.status || "pending").toLowerCase();

        const statusDropdown = document.createElement("select");
        statusDropdown.className = "status-dropdown";
        applyStatusColor(statusDropdown, currentStatus);

        let matched = false;

        statusOptions.forEach((status) => {
          const option = document.createElement("option");
          option.value = status;
          option.textContent = status
            .split(" ")
            .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
            .join(" ");
          if (status.toLowerCase() === currentStatus.toLowerCase()) {
            option.selected = true;
            matched = true;
          }
          statusDropdown.appendChild(option);
        });

        // If nothing matched, fallback to 'pending'
        if (!matched) {
          statusDropdown.value = "pending";
          applyStatusColor(statusDropdown, "pending");
        } else {
          applyStatusColor(statusDropdown, currentStatus);
        }

        // If the original status is missing, push 'pending' to database
        if (!order.status || order.status.trim() === "") {
          try {
            await fetch("/dashboard/update-status", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ orderId: order.id, status: "pending" }),
            });
            console.log(
              `‚è≥ Auto-updated blank status to 'pending' for ${order.id}`
            );
            order.status = "pending"; // ‚úÖ Ensure memory copy is updated too
          } catch (err) {
            console.error(
              `‚ùå Failed to save 'pending' status for ${order.id}`,
              err
            );
          }
        }

        // Update status in backend when changed
        statusDropdown.addEventListener("change", async () => {
          const newStatus = statusDropdown.value;
          applyStatusColor(statusDropdown, newStatus); // üîÅ update color immediately
          try {
            await fetch("/dashboard/update-status", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ orderId: order.id, status: newStatus }),
            });
            console.log(
              `‚úÖ Status for order ${order.id} updated to ${newStatus}`
            );
          } catch (err) {
            console.error(
              `‚ùå Failed to update status for order ${order.id}:`,
              err
            );
          }
        });

        const statusWrapper = document.createElement("div");
        statusWrapper.style.marginTop = "0.5rem";
        statusWrapper.appendChild(statusDropdown);
        card.appendChild(statusWrapper); // Place dropdown below the name

        // Show estimated price right under heading
        const price = document.createElement("p");
        price.innerHTML = `<strong>Est. Price:</strong> ${order.est_price ? `$${order.est_price.toFixed(2)}` : "‚Äî"
          }`;
        card.appendChild(price);

        const toggleBtn = document.createElement("button");
        toggleBtn.className = "details-toggle";
        toggleBtn.textContent = "Show Details ‚ñº";
        card.appendChild(toggleBtn);

        const detailsSection = document.createElement("div");
        detailsSection.className = "details-section";
        card.appendChild(detailsSection);

        const idLine = document.createElement("div");
        idLine.className = "order-id";
        idLine.textContent = `Order ID: ${order.id}`;
        card.appendChild(idLine);


        const table = document.createElement("table");
        table.className = "details-table";
        const submittedDate = new Date(order.submitted_at);
        const formattedDate = submittedDate.toLocaleString("en-US", {
          year: "numeric",
          month: "short",
          day: "numeric",
          hour: "2-digit",
          minute: "2-digit",
          hour12: true,
        });

        [
          ["Email", order.email],
          ["Phone", order.phone],
          ["Staff", order.assigned_staff || "‚Äî"],
          ["Customer Notes", order.notes || "‚Äî"],
          ["Staff Notes", order.order_notes || "‚Äî"],
          ["Submitted At", formattedDate],
        ].forEach(([label, value]) => {
          const row = document.createElement("tr");
          row.innerHTML = `<td>${label}:</td><td>${value}</td>`;
          table.appendChild(row);
        });

        detailsSection.appendChild(table);

        toggleBtn.onclick = () => {
          const visible = detailsSection.classList.toggle("visible");
          toggleBtn.textContent = visible ? "Hide ‚ñ≤" : "Show Details ‚ñº";
        };

        // Expand by default if search is active
        if (expandDetails) {
          detailsSection.classList.add("visible");
          toggleBtn.textContent = "Hide ‚ñ≤";
        }

        fetch(`/dashboard/files/${order.id}`)
          .then((res) => res.json())
          .then((files) => {
            if (files.length > 0) {
              const stlTitle = document.createElement("p");
              stlTitle.className = "stl-header";
              stlTitle.textContent = "STL Files:";
              detailsSection.appendChild(stlTitle); // ‚úÖ append to details section

              const list = document.createElement("ul");
              list.className = "stl-list";

              files.forEach((fileUrl) => {
                const fullFilename = decodeURIComponent(
                  fileUrl.split("/").pop()
                );
                const downloadUrl = `/dashboard/fileserve/${encodeURIComponent(
                  fullFilename
                )}`;
                const filename = fullFilename.replace(
                  /^order[_-]?[a-zA-Z0-9]+[_-]/i,
                  ""
                );

                const li = document.createElement("li");
                li.innerHTML = `
                            <a href="${downloadUrl}" title="${filename}" class="stl-link" download target="_blank">
                              ${filename}
                            </a>`;
                list.appendChild(li);
              });

              detailsSection.appendChild(list); // ‚úÖ append to details section

              if (files.length > 0) {
                const downloadAll = document.createElement("a");
                downloadAll.href = `/dashboard/download-all/${order.id}`;
                downloadAll.className = "download-all-btn";
                downloadAll.textContent = "üì¶ Download All";
                detailsSection.appendChild(downloadAll); // ‚úÖ append to details section
              }
            }

            const isClaimed = order.claimed === true;
            const isCompleted = order.status?.toLowerCase() === "completed";

            if (currentTab === "claimed") {
              // Show "Unclaim" button in Claimed tab
              const unclaimBtn = document.createElement("button");
              unclaimBtn.textContent = "Unclaim";
              unclaimBtn.style.backgroundColor = "#ccc";
              unclaimBtn.style.border = "none";
              unclaimBtn.style.color = "#333";
              unclaimBtn.style.padding = "0.5rem 1rem";
              unclaimBtn.style.borderRadius = "0.5rem";
              unclaimBtn.style.marginTop = "0.5rem";
              unclaimBtn.style.cursor = "pointer";

              unclaimBtn.addEventListener("click", () => {
                order.claimed = false;
                const query = document.getElementById("searchInput").value;
                filterOrders(query);
              });

              card.appendChild(unclaimBtn);
            } else {
              // Don't show claim button for completed orders
              if (isCompleted) {
                const completedLabel = document.createElement("button");
                completedLabel.textContent = "Completed";
                completedLabel.disabled = true;
                completedLabel.style.backgroundColor = "#999";
                completedLabel.style.border = "none";
                completedLabel.style.color = "#666";
                completedLabel.style.padding = "0.5rem 1rem";
                completedLabel.style.borderRadius = "0.5rem";
                completedLabel.style.marginTop = "0.5rem";
                completedLabel.style.cursor = "not-allowed";
                card.appendChild(completedLabel);
              } else {
                // Show "Claim" or "Claimed" for eligible orders
                const claimBtn = document.createElement("button");
                claimBtn.textContent = isClaimed ? "Claimed" : "Claim Order";
                claimBtn.disabled = isClaimed;
                claimBtn.style.backgroundColor = isClaimed ? "#999" : "#ccc";
                claimBtn.style.border = "none";
                claimBtn.style.color = "#333";
                claimBtn.style.padding = "0.5rem 1rem";
                claimBtn.style.borderRadius = "0.5rem";
                claimBtn.style.marginTop = "0.5rem";
                claimBtn.style.cursor = isClaimed ? "not-allowed" : "pointer";

                if (!isClaimed) {
                  claimBtn.addEventListener("click", () => {
                    order.claimed = true;
                    const query = document.getElementById("searchInput").value;
                    filterOrders(query);
                  });
                }

                card.appendChild(claimBtn);
              }
            }


          })

          .catch((err) => {
            console.error(`‚ùå Failed to load STL files for ${order.id}`, err);
          });

        grid.appendChild(card);

        if (
          (order.est_price == null || order.est_price === 0) &&
          !(
            order.order_notes &&
            order.order_notes.includes("Print estimate failed")
          )
        ) {
          autoEstimateOrder(order, card);
        }
      }
    }

    function applyStatusColor(dropdown, status) {
      const normalized = status.toLowerCase().replace(/\s+/g, "-");
      dropdown.className = "status-dropdown status-" + normalized;
    }

    function filterOrders(query) {
      const q = query.toLowerCase();
      const isSearchActive = q.trim().length > 0;

      const filtered = state.allOrders.filter((order) => {
        if (currentTab === "claimed" && !order.claimed) return false;

        return (
          (order.name && order.name.toLowerCase().includes(q)) ||
          (order.email && order.email.toLowerCase().includes(q)) ||
          (order.phone && order.phone.toLowerCase().includes(q)) ||
          (order.id &&
            (order.id.toLowerCase().includes(q) ||
              order.id.replace(/^order_/, "").includes(q)))
        );
      });

      renderOrders(filtered, isSearchActive);
    }

    let latestTimestamp = null;

    // Append new orders to the list and render

    function renderOrdersToContainer(orders, container) {
      renderOrders(orders, false, container);
    }

    async function appendNewOrders(newOrders) {
      if (newOrders.length === 0) return;

      const existingIds = new Set(allOrders.map((order) => order.id));
      const uniqueNewOrders = newOrders.filter(
        (order) => !existingIds.has(order.id)
      );

      if (uniqueNewOrders.length === 0) return;

      for (const order of uniqueNewOrders) {
        allOrders.unshift(order);
        const query = document.getElementById("searchInput").value;
        if (!query.trim()) {
          // Only append if not in a filtered search view
          const grid = document.getElementById("orderGrid");
          const tempOrders = [order];
          const tempHTML = document.createElement("div");
          renderOrdersToContainer(tempOrders, tempHTML); // custom helper
          grid.prepend(...tempHTML.children);
        } // Reuse main render function to show correctly

        // Trigger auto estimate if missing
        if (
          (order.est_price == null || order.est_price === 0) &&
          !(
            order.order_notes &&
            order.order_notes.includes("Print estimate failed")
          )
        ) {
          await autoEstimateOrder(order);
        }
      }

      // Update latest timestamp
      allOrders.sort(
        (a, b) => new Date(b.submitted_at) - new Date(a.submitted_at)
      );
      latestTimestamp = allOrders[0].submitted_at;
    }

    async function refreshOrderStatuses() {
      try {
        const response = await fetch("/dashboard/data", {
          credentials: "include", // ‚úÖ Ensures session cookie is sent
        });

        if (!response.ok) {
          throw new Error(`Request failed: ${response.status}`);
        }

        const latestData = await response.json();
        const grid = document.getElementById("orderGrid");
        const cards = grid.querySelectorAll(".card");

        latestData.forEach((latestOrder) => {
          const matchingCard = [...cards].find((card) =>
            card.innerText.includes(latestOrder.id)
          );

          if (matchingCard) {
            const dropdown = matchingCard.querySelector("select");
            const currentStatus = dropdown.value.toLowerCase();
            let newStatus = (latestOrder.status || "pending").toLowerCase();

            const allowedStatuses = [
              "pending",
              "pre print",
              "printing",
              "printing pay later",
              "completed",
            ];
            if (!allowedStatuses.includes(newStatus)) {
              newStatus = "pending";
            }

            if (currentStatus !== newStatus) {
              dropdown.value = newStatus;
              applyStatusColor(dropdown, newStatus);
            }
          }
        });
      } catch (err) {
        console.error("‚ùå Failed to refresh statuses:", err);
      }
    }

    // First full load
    async function loadInitialOrders() {
      try {
        const data = await api.fetchOrders();
        state.allOrders = Array.isArray(data) ? data : [];
        const query = document.getElementById("searchInput").value;
        filterOrders(query);
      } catch (err) {
        state.allOrders = [];
        document.getElementById("orderGrid").innerHTML = "<p>‚ö†Ô∏è Failed to load orders.</p>";
        console.error("‚ùå Failed to load initial orders:", err);
      }
    }

    // Only get orders submitted after the latest known one
    function fetchNewOrders() {
      if (!latestTimestamp) return;

      fetch(`/dashboard/data?since=${encodeURIComponent(latestTimestamp)}`)
        .then((res) => res.json())
        .then((data) => {
          if (data.length > 0) {
            appendNewOrders(data);
          }
        })
        .catch((err) => {
          console.error("‚ùå Failed to fetch new orders:", err);
        });
    }

    //loadInitialOrders();
    //setInterval(fetchNewOrders, 10000); // Check for new orders every 30s

    let searchTimeout; // Holds the timer reference

    document.getElementById("searchInput").addEventListener("input", () => {
      clearTimeout(searchTimeout); // Cancel the previous timer if user types again

      searchTimeout = setTimeout(() => {
        const query = document.getElementById("searchInput").value;
        filterOrders(query); // Run the actual filtering after 200ms pause
      }, 200);
    });

    async function autoEstimateOrder(order, card) {
      try {
        const files = await fetch(`/dashboard/files/${order.id}`).then((r) =>
          r.json()
        );
        if (!files.length) {
          console.log(`‚è≠Ô∏è Skipped ${order.id} ‚Äî No STL files found.`);
          return;
        }

        const formData = new FormData();
        const fileNames = [];

        for (const fileUrl of files) {
          const response = await fetch(fileUrl);
          const blob = await response.blob();
          const filename = decodeURIComponent(fileUrl.split("/").pop());
          formData.append("stl", blob, filename);
          fileNames.push(filename);
        }

        const sseResponse = await fetch("/stl/upload", {
          method: "POST",
          headers: {
            Origin: "https://filamentbros.com",
          },
          body: formData,
        });

        const reader = sseResponse.body.getReader();
        const decoder = new TextDecoder("utf-8");
        let buffer = "";
        let totalEstimate = 0;
        let failedFiles = [];

        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });

          const events = buffer.split("\n\n");
          buffer = events.pop(); // Keep last incomplete

          for (const event of events) {
            if (event.startsWith("data:")) {
              const data = JSON.parse(event.replace("data:", "").trim());
              if (data.status === "success" && data.price) {
                totalEstimate += parseFloat(data.price);
              } else if (data.status === "error") {
                failedFiles.push(data.file || "Unknown file");
              }
            }
          }
        }

        if (totalEstimate > 0) {
          await fetch("/dashboard/update-price", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              orderId: order.id,
              est_price: totalEstimate.toFixed(2),
            }),
          });
          console.log(
            `‚úÖ Updated order ${order.id
            } with estimate $${totalEstimate.toFixed(2)}`
          );
        }

        if (card) {
          const priceLine = card.querySelector("p");
          if (priceLine) {
            priceLine.innerHTML = `<strong>Est. Price:</strong> $${totalEstimate.toFixed(
              2
            )}`;
          }

          if (failedFiles.length > 0) {
            const message = `‚ö†Ô∏è Print estimate failed for: ${failedFiles.join(
              ", "
            )}`;

            // Update in database
            await fetch("/dashboard/update-notes", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                orderId: order.id,
                order_notes: message,
              }),
            });

            // Update UI immediately
            const notesLine = [...card.querySelectorAll("li")].find((li) =>
              li.innerHTML.includes("Staff Notes:")
            );
            if (notesLine) {
              notesLine.innerHTML = `<strong>Staff Notes:</strong> ${message}`;
            }
          }
        }
      } catch (err) {
        console.error(
          `‚ùå Failed to auto-estimate for order ${order.id}:`,
          err
        );
      }
    }

    //setInterval(refreshOrderStatuses, 10000); // every 10 seconds

    document.addEventListener("DOMContentLoaded", () => {
      const loginOverlay = document.getElementById("loginOverlay");
      const loginForm = document.getElementById("loginForm");
      const loginError = document.getElementById("loginError");

      // Auto-login if remembered
      if (localStorage.getItem("rememberedUser")) {
        fetch("/dashboard/whoami", { credentials: "include" })
          .then((res) => res.json())
          .then((data) => {
            currentUser = data.username;
            loginOverlay.style.display = "none";
            loadInitialOrders();
            socket.connect(); // Connect WebSocket after successful auth
          })
          .catch(() => {
            console.warn("Failed to auto-login");
            localStorage.removeItem("rememberedUser");
          });
      }

      loginForm.addEventListener("submit", async (e) => {
        e.preventDefault();
        const username = document
          .getElementById("username")
          .value.trim()
          .toLowerCase();
        const password = document.getElementById("password").value.trim();
        const remember = document.getElementById("rememberMe").checked;

        const formData = new URLSearchParams();
        formData.append("username", username);
        formData.append("password", password);
        if (remember) formData.append("remember", "on");

        try {
          const res = await fetch("/dashboard/login", {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: formData.toString(),
          });

          if (res.ok) {
            if (remember) localStorage.setItem("rememberedUser", "true");

            // üîÑ Get the actual username from backend session
            const userRes = await fetch("/dashboard/whoami", {
              credentials: "include",
            });
            const data = await userRes.json();
            currentUser = data.username;

            loginOverlay.style.display = "none";

            loadInitialOrders();
            socket.connect(); // Connect WebSocket after successful auth
          } else {
            let errorText = "Login failed.";
            try {
              const data = await res.json();
              errorText = data.error || errorText;
            } catch {
              // if not JSON, fallback
              const fallbackText = await res.text();
              errorText = fallbackText || errorText;
            }
            loginError.textContent = errorText;
            loginError.style.display = "block";
          }
        } catch (err) {
          loginError.textContent = "Login error. Try again.";
          loginError.style.display = "block";
        }
      });
    });

    document.getElementById("tabAll").addEventListener("click", () => {
      currentTab = "all";
      updateTabStyles();
      const query = document.getElementById("searchInput").value;
      filterOrders(query);
    });

    document.getElementById("tabClaimed").addEventListener("click", () => {
      currentTab = "claimed";
      updateTabStyles();
      const query = document.getElementById("searchInput").value;
      filterOrders(query);
    });

    function updateTabStyles() {
      document.getElementById("tabAll").style.backgroundColor = currentTab === "all" ? "#1f6463" : "#ccc";
      document.getElementById("tabAll").style.color = currentTab === "all" ? "white" : "black";
      document.getElementById("tabClaimed").style.backgroundColor = currentTab === "claimed" ? "#1f6463" : "#ccc";
      document.getElementById("tabClaimed").style.color = currentTab === "claimed" ? "white" : "black";
    }


    document.getElementById("showOldToggle").addEventListener("change", async () => {
      try {
        // Fetch new data with current filters
        const data = await api.fetchOrders();
        state.allOrders = Array.isArray(data) ? data : [];
        
        // Apply current search filter
        const query = document.getElementById("searchInput").value;
        filterOrders(query);
      } catch (err) {
        console.error("‚ùå Failed to update orders:", err);
      }
    });

    document.getElementById("showCompletedToggle").addEventListener("change", async () => {
      try {
        // Fetch new data with current filters
        const data = await api.fetchOrders();
        state.allOrders = Array.isArray(data) ? data : [];
        
        // Apply current search filter
        const query = document.getElementById("searchInput").value;
        filterOrders(query);
      } catch (err) {
        console.error("‚ùå Failed to update orders:", err);
      }
    });

  </script>



  <div id="loginOverlay" class="login-overlay">
    <div class="login-box">
      <h2>FilamentBros Login</h2>
      <form id="loginForm">
        <input type="text" id="username" placeholder="Username" required />
        <input type="password" id="password" placeholder="Password" required />
        <label class="remember-line">
          <input type="checkbox" id="rememberMe" />
          Remember Me
        </label>
        <button type="submit">Login</button>
        <p id="loginError" style="color: red; display: none; font-size: 0.85rem"></p>
      </form>
    </div>
  </div>
</body>

</html>