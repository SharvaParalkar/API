<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FilamentBros Order Dashboard</title>
  <style>
    body {
      font-family: "Roboto", sans-serif;
      margin: 0;
      padding: 2rem;
      background-color: #f5f5f5;
    }

    h1 {
      text-align: center;
      color: #1f6463;
      margin-bottom: 1rem;
    }

    .search-container {
      max-width: 700px;
      margin-left: auto;
      margin-right: auto;
      margin-bottom: 2rem;
      display: flex;
      gap: 1rem;
      align-items: center;
      justify-content: center;
      width: 100%;
      padding: 0 1rem;
    }

    .search-container input {
      width: 100%;
      max-width: 700px;
      flex: 1;
      padding: 0.75rem;
      font-size: 1rem;
      border: 2px solid #ccc;
      border-radius: 5rem;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
      gap: 1.5rem;
      align-items: start;
    }

    .card {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      background: white;
      border-radius: 1rem;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      padding: 1.5rem;
      color: #333;
      position: relative;
      height: auto;
      gap: 0.75rem;
    }

    .card h2 {
      font-size: 1.2rem;
      color: #1f6463;
      margin: 0 0 -0.25rem 0;
      padding-right: 2rem;
    }

    .status-wrapper {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin: 0;
    }

    .status-dropdown {
      padding: 0.5rem;
      border-radius: 1rem;
      border: 1px solid #ccc;
      font-size: 0.9rem;
      min-width: 150px;
      cursor: pointer;
    }

    .details-toggle {
      margin: 0;
      font-size: 0.85rem;
      color: #1f6463;
      background: none;
      border: none;
      font-weight: bold;
      cursor: pointer;
      padding: 0.25rem 0;
    }

    .details-section {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.6s ease, opacity 0.6s ease;
      opacity: 0;
      margin: 0;
      border-top: 1px solid #eee;
      padding-top: 0.75rem;
    }

    .details-section.visible {
      max-height: 1000px;
      opacity: 1;
      margin-top: 0.5rem;
    }

    .details-table {
      width: 100%;
      font-size: 0.9rem;
      border-spacing: 0 0.75rem;
      table-layout: fixed;
    }

    .details-table td:first-child {
      width: 120px;
      color: #666;
      vertical-align: top;
      padding-right: 1rem;
    }

    .assigned-price-input {
      width: 120px;
      padding: 0.4rem 0.4rem 0.4rem 1.5rem;
      border: 1px solid #ccc;
      border-radius: 0.3rem;
      font-size: 0.9rem;
      margin-bottom: 0.5rem;
    }

    .assigned-price-input:focus {
      border-color: #1f6463;
      outline: none;
      box-shadow: 0 0 0 2px rgba(31, 100, 99, 0.1);
    }

    .price-input-wrapper {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }

    .dollar-sign {
      position: absolute;
      left: 0.5rem;
      top: 0.4rem;
      color: #666;
      font-size: 0.9rem;
      pointer-events: none;
    }

    .save-price-btn {
      padding: 0.3rem 0.6rem;
      background-color: #1f6463;
      color: white;
      border: none;
      border-radius: 0.3rem;
      cursor: pointer;
      font-size: 0.85rem;
      transition: background-color 0.2s ease;
      width: 120px;
    }

    .save-price-btn:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    .details-divider {
      border-top: 1px solid #eee;
      margin: 1rem 0;
      width: 100%;
    }

    .staff-selection-container {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      margin: 0;
    }

    .staff-tags-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      padding: 0.75rem;
      border-radius: 0.5rem;
      background-color: #f5f5f5;
      margin-top: 0.25rem;
    }

    .staff-tag {
      background-color: #e0e0e0;
      color: #333;
      padding: 0.4rem 0.8rem;
      border-radius: 0.5rem;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      cursor: pointer;
      transition: all 0.2s ease;
      user-select: none;
      font-size: 0.9rem;
    }

    .staff-notes-editor {
      width: 100%;
      min-height: 100px;
      padding: 0.75rem;
      border: 1px solid #ccc;
      border-radius: 0.3rem;
      margin: 0.5rem 0;
      font-family: inherit;
      font-size: 0.9rem;
      resize: vertical;
      background-color: #fff;
      white-space: pre-wrap;
      word-wrap: break-word;
      box-sizing: border-box;
      line-height: 1.4;
    }

    .save-notes-btn {
      padding: 0.4rem 0.8rem;
      background-color: #1f6463;
      color: white;
      border: none;
      border-radius: 0.3rem;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background-color 0.2s ease;
      margin-bottom: 0.5rem;
    }

    .save-notes-btn:disabled {
      background-color: #ccc;
      color: white;
      cursor: not-allowed;
    }

    .order-id {
      margin-top: 0.5rem;
      padding-top: 0.5rem;
      border-top: 1px solid #ddd;
      text-align: center;
      font-size: 0.8rem;
      color: #666;
      font-weight: bold;
    }

    .action-button {
      border: none;
      color: #333;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      margin-top: 0.25rem;
      transition: all 0.2s ease;
      background-color: #ccc;
      cursor: pointer;
      width: 100%;
      font-size: 0.9rem;
    }

    .card ul {
      padding-left: 1rem;
      margin: 0;
      font-size: 0.95rem;
      list-style: disc;
    }

    .card:hover {
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.15);
      transform: translateY(-3px);
      transition: 0.2s ease;
    }

    .card ul li {
      margin-bottom: 0.5rem;
    }

    .stl-header {
      font-weight: bold;
      margin-top: 1rem;
      margin-bottom: 0.5rem;
    }

    .stl-list {
      padding-left: 1.2rem;
      list-style-type: disc;
      margin-top: 0;
      margin-bottom: 0.75rem;
    }

    .stl-list li {
      font-size: 0.9rem;
      margin-bottom: 0.35rem;
    }

    .stl-link {
      display: block;
      max-width: 100%;
      color: #1f6463;
      text-decoration: none;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: normal;
      word-break: break-word;
      /* Ensures long words break cleanly */
    }

    .download-all-btn {
      margin-top: 0.25rem;
      display: inline-block;
      margin-top: 0.5rem;
      padding: 0.4rem 0.75rem;
      background-color: #1f6463;
      color: white;
      text-decoration: none;
      border-radius: 6px;
      font-size: 0.85rem;
    }

    .status-submitted {
      background-color: #1f6463;
    }

    .status-complete {
      background-color: #5cb85c;
    }

    .status-failed {
      background-color: #d9534f;
    }

    .status-pending {
      background-color: #ff6e5f;
      color: #000;
    }

    .status-pre-print {
      background-color: #ffaea5;
      color: #000;
    }

    .status-printing {
      background-color: #f4d03f;
      color: #000;
    }

    .status-printing-pay-later {
      background-color: #f4d03f;
      color: #000;
    }

    .status-completed {
      background-color: #2ecc71;
      color: #000;
    }

    .toggle-wrapper {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
      flex-shrink: 0;
    }

    .toggle-wrapper input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: 0.3s;
      border-radius: 24px;
    }

    .slider::before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }

    .toggle-wrapper input:checked+.slider {
      background-color: #1f6463;
    }

    .toggle-wrapper input:checked+.slider::before {
      transform: translateX(20px);
    }

    .toggle-label {
      font-size: 0.9rem;
      margin-left: 0.5rem;
      line-height: 24px;
      color: #333;
    }

    .top-bar {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 2rem;
      flex-direction: column;
    }

    .toggle-group {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .login-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: white;
      z-index: 9999;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .login-box {
      background: white;
      padding: 2rem;
      border-radius: 1rem;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
      width: 100%;
      max-width: 360px;
      text-align: center;

      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .login-box input[type="text"],
    .login-box input[type="password"] {
      width: 100%;
      padding: 0.75rem;
      margin-bottom: 1rem;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 0.5rem;
      box-sizing: border-box;
      /* ✅ prevents padding from adding to width */
    }

    .login-box button {
      width: 100%;
      padding: 0.75rem;
      font-size: 1rem;
      background-color: #1f6463;
      color: white;
      border: none;
      border-radius: 0.5rem;
      cursor: pointer;
    }

    .login-box .remember-line {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      font-size: 0.9rem;
      margin-bottom: 1rem;
      justify-content: left;
    }

    .toggles-wrapper {
      display: flex;
      gap: 1rem;
    }

    .search-input-wrapper {
      flex-grow: 1;
      max-width: 700px;
      margin: 0 auto;
    }

    .search-bar-wrapper {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 2rem;
      height: 3.5rem;
    }

    .toggles-wrapper {
      position: absolute;
      left: 0;
      display: flex;
      gap: 1rem;
      align-items: center;
      padding-left: 1rem;
    }

    .centered-search {
      max-width: 700px;
      width: 100%;
      padding: 0.75rem;
      font-size: 1rem;
      border: 2px solid #ccc;
      border-radius: 5rem;
    }

    .search-bar-flex {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
      margin-bottom: 2rem;
      width: 100%;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
      padding: 0 1rem;
    }

    .left-toggles {
      display: flex;
      gap: 1rem;
      align-items: center;
      flex-shrink: 0;
    }

    .center-search {
      flex-grow: 1;
      max-width: 700px;
      display: flex;
      justify-content: center;
    }

    .center-search input {
      width: 100%;
      max-width: 700px;
      padding: 0.75rem;
      font-size: 1rem;
      border: 2px solid #ccc;
      border-radius: 5rem;
      outline: none;
    }

    .center-search input:focus {
      border-color: #1f6463;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }

      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }

      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }

    .status-history {
      margin-top: 1rem;
      font-size: 0.9rem;
    }

    .status-history-item {
      display: flex;
      justify-content: space-between;
      padding: 0.5rem;
      border-bottom: 1px solid #eee;
    }

    .status-history-item:last-child {
      border-bottom: none;
    }

    .staff-notes-editor:focus {
      border-color: #1f6463;
      outline: none;
      box-shadow: 0 0 0 2px rgba(31, 100, 99, 0.1);
    }

    .save-notes-btn:hover:not(:disabled) {
      background-color: #184f4e;
    }

    .save-notes-btn:disabled {
      background-color: #ccc;
      color: white;
      cursor: not-allowed;
    }

    /* Style for customer notes */
    .details-table tr:first-child td:last-child {
      white-space: pre-wrap;
      word-break: break-word;
      font-style: italic;
      color: #666;
      background-color: #f9f9f9;
      border-radius: 0.3rem;
      padding: 0.75rem;
      min-height: 2.5rem;
      line-height: 1.4;
      border: 1px solid #eee;
    }

    /* Style for staff notes */
    .staff-notes-editor {
      width: 100%;
      min-height: 100px;
      padding: 0.75rem;
      border: 1px solid #ccc;
      border-radius: 0.3rem;
      margin: 0.5rem 0;
      font-family: inherit;
      font-size: 0.9rem;
      resize: vertical;
      background-color: #fff;
      white-space: pre-wrap;
      word-wrap: break-word;
      box-sizing: border-box;
      line-height: 1.4;
    }

    /* Dark mode support */
    .dark-mode .details-table tr:first-child td:last-child {
      background-color: #2d2d2d;
      border-color: #444;
      color: #aaa;
    }

    .dark-mode .staff-notes-editor {
      background-color: #2d2d2d;
      color: #fff;
      border-color: #444;
    }

    .dark-mode .status-dropdown {
      background-color: #3d3d3d;
      color: #fff;
      border-color: #4d4d4d;
    }

    .dark-mode .staff-notes-editor {
      background-color: #3d3d3d;
      color: #fff;
      border-color: #4d4d4d;
    }

    .dark-mode-toggle {
      position: fixed;
      top: 1rem;
      right: 1rem;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      background-color: #1f6463;
      color: white;
      border: none;
      cursor: pointer;
    }

    .priority-badge {
      display: inline-block;
      padding: 0.2rem 0.5rem;
      border-radius: 0.3rem;
      font-size: 0.8rem;
      margin-left: 0.5rem;
    }

    .priority-high {
      background-color: #ff4444;
      color: white;
    }

    .priority-medium {
      background-color: #ffbb33;
      color: black;
    }

    .priority-low {
      background-color: #00C851;
      color: white;
    }

    .tab-container {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin-bottom: 1rem;
      position: relative;
      z-index: 100;
    }

    .tab-button {
      padding: 0.6rem 1rem;
      border-radius: 1rem;
      border: none;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      transition: all 0.2s ease;
      user-select: none;
      pointer-events: auto;
    }

    .tab-button:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .tab-button:active {
      transform: translateY(0);
    }

    .tab-button.active {
      background-color: #1f6463;
      color: white;
    }

    .tab-button.inactive {
      background-color: #e0e0e0;
      color: #333;
    }

    .tab-button.coupon {
      background-color: #e0e0e0;
      color: #333;
    }

    .tab-button.coupon.active {
      background-color: #1f6463;
      color: white;
    }

    .tab-button.analytics {
      background-color: #e0e0e0;
      color: #333;
    }

    .tab-button.analytics.active {
      background-color: #1f6463;
      color: white;
    }

    /* Add consistent button styles */
    .action-button {
      border: none;
      color: #333;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      margin-top: 0.25rem;
      transition: all 0.2s ease;
      background-color: #ccc;
      cursor: pointer;
    }

    .action-button:disabled {
      background-color: #999;
      cursor: not-allowed;
    }

    .action-button.claiming,
    .action-button.unclaiming {
      background-color: #999;
      cursor: not-allowed;
    }

    /* Add styles for the staff list display */
    .assigned-staff-list {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .staff-tag {
      background-color: #e0e0e0;
      color: #333;
      padding: 0.4rem 0.8rem;
      border-radius: 0.5rem;
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      cursor: pointer;
      transition: all 0.2s ease;
      user-select: none;
    }

    .staff-tag.selected {
      background-color: #1f6463;
      color: white;
      transform: scale(1.02);
    }

    .staff-tag:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }

    .staff-tag:active {
      transform: scale(0.98);
    }

    .staff-selection-container {
      display: flex;
      flex-direction: column;
      gap: 0.8rem;
    }

    .staff-tags-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      padding: 0.5rem;
      border-radius: 0.5rem;
      background-color: #f5f5f5;
    }

    /* Replace the old staff dropdown styles */
    .staff-dropdown {
      padding: 0.5rem;
      border-radius: 1rem;
      border: 1px solid #ccc;
      font-size: 0.9rem;
      min-width: 150px;
      cursor: pointer;
    }

    .delete-btn {
      position: absolute;
      top: 0.75rem;
      right: 0.75rem;
      background-color: #ff4444;
      color: white;
      border: none;
      border-radius: 0.3rem;
      padding: 0.3rem 0.6rem;
      cursor: pointer;
      font-size: 0.9rem;
      opacity: 0.8;
      transition: opacity 0.2s ease;
      z-index: 1;
    }

    .delete-btn:hover {
      opacity: 1;
    }

    .delete-confirmation-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .delete-confirmation-box {
      background-color: white;
      padding: 2rem;
      border-radius: 1rem;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
      text-align: center;
      max-width: 400px;
      width: 90%;
    }

    .delete-confirmation-box h3 {
      margin-top: 0;
      color: #333;
    }

    .delete-confirmation-box p {
      margin: 1rem 0;
      color: #666;
    }

    .delete-confirmation-buttons {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin-top: 1.5rem;
    }

    .delete-confirm-btn {
      background-color: #ff4444;
      color: white;
      border: none;
      padding: 0.6rem 1.2rem;
      border-radius: 0.5rem;
      cursor: pointer;
      font-weight: bold;
    }

    .delete-cancel-btn {
      background-color: #ccc;
      color: #333;
      border: none;
      padding: 0.6rem 1.2rem;
      border-radius: 0.5rem;
      cursor: pointer;
      font-weight: bold;
    }

    .delete-confirm-btn:hover {
      background-color: #ff2222;
    }

    .delete-cancel-btn:hover {
      background-color: #bbb;
    }

    .order-card {
      transition: background-color 0.3s ease;
    }
    .updated {
      background-color: rgba(255, 255, 0, 0.1) !important;
    }
    .submission-time {
      color: #666;
      font-size: 0.9em;
      margin-top: 4px;
    }
    .assigned-staff {
      font-weight: bold;
      color: #2196F3;
    }
  </style>
</head>

<body>
  <h1>FilamentBros Order Dashboard</h1>

  <div class="tab-container">
    <button id="tabAll" class="tab-button"
      style="background: #1f6463; color: white;">All Orders</button>
    <button id="tabClaimed" class="tab-button"
      style="background: #ccc; color: black;">Claimed Orders</button>
    <button id="tabCoupon" class="tab-button coupon"
      style="background: #ccc; color: black;">Coupons</button>
    <button id="tabAnalytics" class="tab-button analytics"
      style="background: #ccc; color: black;">Analytics</button>
  </div>

  <div class="search-bar-flex">
    <div class="left-toggles">
      <div class="toggle-group">
        <span class="toggle-label">Old Orders</span>
        <label class="toggle-wrapper">
          <input type="checkbox" id="showOldToggle" />
          <span class="slider"></span>
        </label>
      </div>

      <div class="toggle-group">
        <span class="toggle-label">Completed</span>
        <label class="toggle-wrapper">
          <input type="checkbox" id="showCompletedToggle" />
          <span class="slider"></span>
        </label>
      </div>

      <div class="toggle-group">
        <select id="staffFilter" style="padding: 0.4rem; border-radius: 1rem; border: 1px solid #ccc;">
          <option value="">All Staff</option>
        </select>
      </div>
    </div>

    <div class="center-search">
      <input type="text" id="searchInput" placeholder="Search by name, email, phone, or order ID..." />
    </div>
  </div>

  <div class="grid" id="orderGrid"></div>

  <script>
    // Constants
    const REFRESH_INTERVAL = 10000; // 10 seconds
    const SEARCH_DEBOUNCE = 200; // 200ms
    const MAX_RETRY_ATTEMPTS = 3;
    const VALID_STATUSES = [
      "pending",
      "pre print",
      "printing",
      "printing pay later",
      "completed",
    ];

    // State management
    const state = {
      allOrders: [],
      currentUser: null,
      currentTab: "all",
      retryCount: 0,
      filters: {
        showOld: false,
        showCompleted: false,
        staffFilter: ""
      },
      intervals: [],
      staffMembers: [],
      lastOrderHash: null,
      lastRefreshTime: 0,
      minRefreshInterval: 5000
    };

    // First full load
    async function loadInitialOrders() {
      try {
        const data = await api.fetchOrders();
        state.allOrders = Array.isArray(data) ? data : [];
        console.log('📦 Initial orders loaded:', state.allOrders.length);

        // Initialize search immediately after orders load
        initializeSearch();

        // Apply any existing search query
        const query = document.getElementById("searchInput").value;
        filterOrders(query);
      } catch (err) {
        state.allOrders = [];
        document.getElementById("orderGrid").innerHTML = "<p>⚠️ Failed to load orders.</p>";
        console.error("❌ Failed to load initial orders:", err);
      }
    }

    // Handle incoming order updates
    function handleOrderUpdate(updatedOrder) {
      console.log('🔄 Processing order update:', updatedOrder);

      // Update order in state
      const index = state.allOrders.findIndex(order => order.id === updatedOrder.id);
      if (index !== -1) {
        state.allOrders[index] = updatedOrder;
      } else {
        state.allOrders.unshift(updatedOrder);
      }

      // Get the existing card
      const orderCard = document.querySelector(`[data-order-id="${updatedOrder.id}"]`);
      if (!orderCard) {
        console.log(`Card not found for order ${updatedOrder.id}, refreshing view...`);
        const query = document.getElementById("searchInput").value;
        filterOrders(query);
        return;
      }

      // Handle claimed tab visibility
      if (state.currentTab === "claimed") {
        const assignedStaffList = updatedOrder.assigned_staff ? updatedOrder.assigned_staff.split(',') : [];
        const shouldBeVisible = (
          (updatedOrder.claimed_by === state.currentUser || assignedStaffList.includes(state.currentUser)) &&
          updatedOrder.status?.toLowerCase() !== "completed"
        );
        
        if (!shouldBeVisible) {
          console.log(`Removing card ${updatedOrder.id} from claimed view`);
          orderCard.style.transition = "all 0.3s ease";
          orderCard.style.opacity = "0";
          orderCard.style.transform = "scale(0.9)";
          setTimeout(() => {
            if (orderCard.isConnected) {
              orderCard.remove();
            }
          }, 300);
          return;
        }
      }

      // Update status dropdown
      const statusDropdown = orderCard.querySelector('.status-dropdown');
      if (statusDropdown) {
        const newStatus = updatedOrder.status || 'pending';
        console.log(`Updating status for order ${updatedOrder.id} to:`, newStatus);
        statusDropdown.value = newStatus;
        statusDropdown.dataset.previousValue = newStatus;
        applyStatusColor(statusDropdown, newStatus);
      }

      // Update claim/unclaim button
      const actionBtn = orderCard.querySelector('.action-button:not(.save-notes-btn)');
      if (actionBtn) {
        if (updatedOrder.status?.toLowerCase() === 'completed') {
          // Replace with completed label
          const completedLabel = document.createElement("button");
          completedLabel.textContent = "Completed";
          completedLabel.disabled = true;
          completedLabel.className = "action-button";
          completedLabel.style.backgroundColor = "#999";
          completedLabel.style.color = "#666";
          completedLabel.style.cursor = "not-allowed";
          actionBtn.replaceWith(completedLabel);
        } else if (updatedOrder.claimed_by === state.currentUser) {
          // Replace with unclaim button if not already an unclaim button
          if (!actionBtn.textContent.includes('Unclaim')) {
            actionBtn.replaceWith(createUnclaimButton(updatedOrder));
          }
        } else {
          // Update or replace with claim button
          const newClaimBtn = document.createElement('button');
          newClaimBtn.className = 'action-button';
          
          if (updatedOrder.claimed_by) {
            newClaimBtn.textContent = `Claimed by ${updatedOrder.claimed_by}`;
            newClaimBtn.disabled = true;
            newClaimBtn.style.backgroundColor = '#999';
            newClaimBtn.style.cursor = 'not-allowed';
          } else {
            newClaimBtn.textContent = 'Claim Order';
            newClaimBtn.addEventListener('click', async () => {
              try {
                newClaimBtn.textContent = 'Claiming...';
                newClaimBtn.disabled = true;
                newClaimBtn.classList.add('claiming');

                const response = await api.claimOrder(updatedOrder.id);
                
                if (response && response.order) {
                  Object.assign(updatedOrder, response.order);
                  updateStaffTagsForOrder(orderCard, [state.currentUser]);
                  newClaimBtn.replaceWith(createUnclaimButton(updatedOrder));
                }
              } catch (err) {
                console.error(`Failed to claim order ${updatedOrder.id}:`, err);
                ui.showError(err.message || "Failed to claim order");
                newClaimBtn.textContent = 'Claim Order';
                newClaimBtn.disabled = false;
                newClaimBtn.classList.remove('claiming');
              }
            });
          }
          
          actionBtn.replaceWith(newClaimBtn);
        }
      }

      // Update staff tags
      const assignedStaff = updatedOrder.assigned_staff ? updatedOrder.assigned_staff.split(',') : [];
      updateStaffTagsForOrder(orderCard, assignedStaff);

      // Update other card elements
      updateCardElements(orderCard, updatedOrder);

      // Update staff notes if they exist
      let staffNotesEditor = orderCard.querySelector(".staff-notes-editor");
      let saveNotesBtn = orderCard.querySelector(".save-notes-btn");
      
      if (staffNotesEditor && updatedOrder.order_notes !== undefined) {
        // Only update if the editor is not currently focused (being edited)
        const isEditorFocused = staffNotesEditor === document.activeElement;
        const currentValue = staffNotesEditor.value;
        
        if (!isEditorFocused) {
          staffNotesEditor.value = updatedOrder.order_notes || '';
          staffNotesEditor.dataset.previousValue = updatedOrder.order_notes || '';
        }

        // Ensure the editor remains editable
        staffNotesEditor.disabled = false;
        staffNotesEditor.readOnly = false;

        // Reset save button state
        if (saveNotesBtn) {
          const hasChanges = currentValue !== (updatedOrder.order_notes || '');
          saveNotesBtn.disabled = !hasChanges;
          
          if (hasChanges) {
            saveNotesBtn.textContent = "Save Notes";
            saveNotesBtn.style.backgroundColor = "#1f6463";
            saveNotesBtn.style.cursor = "pointer";
          } else {
            saveNotesBtn.textContent = "No Changes";
            saveNotesBtn.style.backgroundColor = "#ccc";
            saveNotesBtn.style.cursor = "not-allowed";
          }
        }

        // Reattach event listeners
        const reattachListeners = (editor, saveBtn) => {
          // Clear existing listeners
          const newEditor = editor.cloneNode(true);
          editor.parentNode.replaceChild(newEditor, editor);

          // Add input event listener
          newEditor.addEventListener('input', () => {
            const currentValue = newEditor.value;
            const previousValue = newEditor.dataset.previousValue || '';
            const hasChanges = currentValue !== previousValue;
            
            if (saveBtn) {
              saveBtn.disabled = !hasChanges;
              if (hasChanges) {
                saveBtn.textContent = "Save Notes";
                saveBtn.style.backgroundColor = "#1f6463";
                saveBtn.style.cursor = "pointer";
              } else {
                saveBtn.textContent = "No Changes";
                saveBtn.style.backgroundColor = "#ccc";
                saveBtn.style.cursor = "not-allowed";
              }
            }
          });

          // Handle paste and cut events
          ['paste', 'cut'].forEach(eventName => {
            newEditor.addEventListener(eventName, () => {
              setTimeout(() => newEditor.dispatchEvent(new Event('input')), 0);
            });
          });

          // Add Ctrl+Enter / Cmd+Enter save shortcut
          newEditor.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter' && !saveNotesBtn.disabled) {
              e.preventDefault();
              saveNotesBtn.click();
            }
          });

          // Update save button click handler
          if (saveBtn) {
            const newSaveBtn = saveBtn.cloneNode(true);
            saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
            
            newSaveBtn.addEventListener('click', () => {
              if (newEditor.value !== newEditor.dataset.previousValue) {
                saveStaffNotes(updatedOrder.id, newEditor.value, newEditor, newSaveBtn);
              }
            });
          }

          return newEditor;
        };

        // Reattach all listeners
        staffNotesEditor = reattachListeners(staffNotesEditor, saveNotesBtn);
      }

      // Store the current state of the staff notes and details section
      const detailsSection = orderCard.querySelector('.details-section');
      const isExpanded = detailsSection?.classList.contains('visible');
      const currentNotesValue = staffNotesEditor ? staffNotesEditor.value : '';
      const isEditorFocused = staffNotesEditor === document.activeElement;
      const cursorPosition = staffNotesEditor ? staffNotesEditor.selectionStart : 0;

      // If the card was expanded, we need to re-expand it and restore the staff notes
      if (isExpanded) {
        const newDetailsSection = orderCard.querySelector('.details-section');
        const newToggleBtn = orderCard.querySelector('.details-toggle');
        const newStaffNotesEditor = orderCard.querySelector('.staff-notes-editor');
        const newSaveNotesBtn = orderCard.querySelector('.save-notes-btn');

        if (newDetailsSection) {
          newDetailsSection.classList.add('visible');
        }
        
        if (newToggleBtn) {
          newToggleBtn.textContent = "Hide ▲";
        }

        // Always reinitialize the staff notes editor with fresh data
        if (newStaffNotesEditor) {
          // If the editor was being edited, preserve the current state
          if (isEditorFocused) {
            newStaffNotesEditor.value = currentNotesValue;
            newStaffNotesEditor.dataset.previousValue = updatedOrder.order_notes || '';
            setTimeout(() => {
              newStaffNotesEditor.focus();
              newStaffNotesEditor.setSelectionRange(cursorPosition, cursorPosition);
            }, 0);
          } else {
            // Otherwise use the latest data from the server
            newStaffNotesEditor.value = updatedOrder.order_notes || '';
            newStaffNotesEditor.dataset.previousValue = updatedOrder.order_notes || '';
          }

          // Ensure the editor is enabled
          newStaffNotesEditor.disabled = false;
          newStaffNotesEditor.readOnly = false;

          // Update save button state
          if (newSaveNotesBtn) {
            const hasChanges = newStaffNotesEditor.value !== newStaffNotesEditor.dataset.previousValue;
            newSaveNotesBtn.disabled = !hasChanges;
            newSaveNotesBtn.textContent = hasChanges ? "Save Notes" : "No Changes";
            newSaveNotesBtn.style.backgroundColor = hasChanges ? "#1f6463" : "#ccc";
            newSaveNotesBtn.style.cursor = hasChanges ? "pointer" : "not-allowed";
          }

          // Reattach all event listeners
          const reattachEditorListeners = () => {
            // Clear existing listeners
            const freshEditor = newStaffNotesEditor.cloneNode(true);
            newStaffNotesEditor.parentNode.replaceChild(freshEditor, newStaffNotesEditor);

            // Add input event listener
            freshEditor.addEventListener('input', () => {
              const hasChanges = freshEditor.value !== freshEditor.dataset.previousValue;
              if (newSaveNotesBtn) {
                newSaveNotesBtn.disabled = !hasChanges;
                newSaveNotesBtn.textContent = hasChanges ? "Save Notes" : "No Changes";
                newSaveNotesBtn.style.backgroundColor = hasChanges ? "#1f6463" : "#ccc";
                newSaveNotesBtn.style.cursor = hasChanges ? "pointer" : "not-allowed";
              }
            });

            // Handle paste and cut events
            ['paste', 'cut'].forEach(eventName => {
              freshEditor.addEventListener(eventName, () => {
                setTimeout(() => freshEditor.dispatchEvent(new Event('input')), 0);
              });
            });

            // Add Ctrl+Enter / Cmd+Enter save shortcut
            freshEditor.addEventListener('keydown', (e) => {
              if ((e.ctrlKey || e.metaKey) && e.key === 'Enter' && !newSaveNotesBtn?.disabled) {
                e.preventDefault();
                newSaveNotesBtn.click();
              }
            });

            return freshEditor;
          };

          // Reattach save button listeners
          const reattachSaveButtonListeners = () => {
            if (!newSaveNotesBtn) return;

            const freshSaveBtn = newSaveNotesBtn.cloneNode(true);
            newSaveNotesBtn.parentNode.replaceChild(freshSaveBtn, newSaveNotesBtn);

            freshSaveBtn.addEventListener('click', () => {
              const editor = orderCard.querySelector('.staff-notes-editor');
              if (editor && editor.value !== editor.dataset.previousValue) {
                saveStaffNotes(updatedOrder.id, editor.value, editor, freshSaveBtn);
              }
            });

            return freshSaveBtn;
          };

          // Apply the reattached listeners
          const freshEditor = reattachEditorListeners();
          const freshSaveBtn = reattachSaveButtonListeners();

          // If we were editing, restore focus
          if (isEditorFocused) {
            setTimeout(() => {
              freshEditor.focus();
              freshEditor.setSelectionRange(cursorPosition, cursorPosition);
            }, 0);
          }
        }
      }
    }

    // Helper function to check if an order should be shown based on current filters
    function shouldShowOrder(order) {
      const showOld = document.getElementById("showOldToggle").checked;
      const showCompleted = document.getElementById("showCompletedToggle").checked;

      // Check completed status
      if (!showCompleted && order.status?.toLowerCase() === 'completed') {
        return false;
      }

      // Check age
      if (!showOld) {
        const oneWeekAgo = new Date();
        oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
        const orderDate = new Date(order.submitted_at);
        if (orderDate < oneWeekAgo) {
          return false;
        }
      }

      return true;
    }

    // Helper function to update card elements
    function updateCardElements(card, order) {
      // Update price
      const priceElement = card.querySelector('p');
      if (priceElement) {
        priceElement.innerHTML = `<strong>Est. Price:</strong> ${order.est_price ? `$${order.est_price.toFixed(2)}` : '—'}`;
      }

      // Update notes if visible
      const detailsSection = card.querySelector('.details-section');
      if (detailsSection?.classList.contains('visible')) {
        const notesCell = [...detailsSection.querySelectorAll('td')].find(td => 
          td.textContent.trim().startsWith('Staff Notes:')
        )?.nextElementSibling;
        if (notesCell) {
          notesCell.textContent = order.order_notes || '—';
        }

        // Update last updated by
        const updatedByCell = [...detailsSection.querySelectorAll('td')].find(td => 
          td.textContent.trim().startsWith('Last Updated By:')
        )?.nextElementSibling;
        if (updatedByCell) {
          updatedByCell.textContent = order.updated_by || '—';
        }
      }
    }

    // Utility functions
    const debounce = (func, wait) => {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    };

    const handleError = async (err, operation) => {
      console.error(`❌ Error during ${operation}:`, err);

      if (err.status === 401) {
        clearAllIntervals();
        showLoginOverlay();
        return;
      }

      if (state.retryCount < MAX_RETRY_ATTEMPTS) {
        state.retryCount++;
        await new Promise(resolve => setTimeout(resolve, 1000 * state.retryCount));
        return true; // Retry
      }

      state.retryCount = 0;
      return false; // Don't retry
    };

    const clearAllIntervals = () => {
      state.intervals.forEach(clearInterval);
      state.intervals = [];
    };

    // API functions
    const api = {
      async fetchOrders() {
        try {
          // Get current filter states
          const showOld = document.getElementById("showOldToggle").checked;
          const showCompleted = document.getElementById("showCompletedToggle").checked;

          // Build query string
          const params = new URLSearchParams({
            showOld: showOld.toString(),
            showCompleted: showCompleted.toString(),
            showClaimed: (state.currentTab === "claimed").toString()
          });

          const url = `/dashboard/data?${params.toString()}`;
          console.log('🔍 Fetching orders with filters:', { showOld, showCompleted, showClaimed: state.currentTab === "claimed" });

          const res = await fetch(url, { credentials: 'include' });
          if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);

          const data = await res.json();
          console.log(`📦 Received ${data.length} orders`);
          return data;
        } catch (err) {
          console.error('❌ Failed to fetch orders:', err);
          return [];
        }
      },

      async updateStatus(orderId, status) {
        try {
          const res = await fetch("/dashboard/update-status", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ orderId, status }),
            credentials: 'include'
          });
          if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
          return await res.json();
        } catch (err) {
          await handleError(err, 'updateStatus');
          throw err;
        }
      },

      async assignStaff(orderId, staffName) {
        try {
          const res = await fetch("/dashboard/assign-staff", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ orderId, staffName }),
            credentials: 'include'
          });
          
          if (!res.ok) {
            const error = new Error(`HTTP error! status: ${res.status}`);
            error.status = res.status;
            error.response = res;
            throw error;
          }
          
          return await res.json();
        } catch (err) {
          await handleError(err, 'assignStaff');
          throw err;
        }
      },

      async claimOrder(orderId) {
        try {
          const res = await fetch("/dashboard/claim", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ orderId }),
            credentials: 'include'
          });
          if (!res.ok) {
            const data = await res.json();
            throw new Error(data.error || `HTTP error! status: ${res.status}`);
          }
          return await res.json();
        } catch (err) {
          await handleError(err, 'claimOrder');
          throw err;
        }
      },

      async unclaimOrder(orderId) {
        try {
          const res = await fetch("/dashboard/unclaim", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ orderId }),
            credentials: 'include'
          });
          if (!res.ok) {
            const data = await res.json();
            throw new Error(data.error || `HTTP error! status: ${res.status}`);
          }
          return await res.json();
        } catch (err) {
          await handleError(err, 'unclaimOrder');
          throw err;
        }
      },

      async login(username, password, remember) {
        try {
          const formData = new URLSearchParams();
          formData.append("username", username);
          formData.append("password", password);
          if (remember) formData.append("remember", "on");

          const res = await fetch("/dashboard/login", {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: formData.toString(),
            credentials: 'include'
          });

          if (!res.ok) {
            const data = await res.json().catch(() => ({ error: "Login failed" }));
            throw new Error(data.error || "Login failed");
          }

          return true;
        } catch (err) {
          console.error("Login error:", err);
          throw err;
        }
      },

      async checkSession() {
        try {
          const res = await fetch("/dashboard/whoami", { credentials: "include" });
          if (!res.ok) throw new Error("Session check failed");
          return await res.json();
        } catch (err) {
          console.error("Session check error:", err);
          throw err;
        }
      },

      async getStaffList() {
        try {
          const res = await fetch("/dashboard/staff", {
            credentials: 'include'
          });
          if (!res.ok) throw new Error("Failed to fetch staff list");
          return await res.json();
        } catch (err) {
          console.error("Failed to fetch staff list:", err);
          return [];
        }
      }
    };

    // UI update functions
    const ui = {
      updateTabStyles() {
        const allTab = document.getElementById("tabAll");
        const claimedTab = document.getElementById("tabClaimed");
        const couponTab = document.getElementById("tabCoupon");
        const analyticsTab = document.getElementById("tabAnalytics");

        if (allTab) allTab.style.background = state.currentTab === "all" ? "#1f6463" : "#ccc";
        if (allTab) allTab.style.color = state.currentTab === "all" ? "white" : "black";
        
        if (claimedTab) claimedTab.style.background = state.currentTab === "claimed" ? "#1f6463" : "#ccc";
        if (claimedTab) claimedTab.style.color = state.currentTab === "claimed" ? "white" : "black";

        if (couponTab) couponTab.style.background = state.currentTab === "coupon" ? "#1f6463" : "#ccc";
        if (couponTab) couponTab.style.color = state.currentTab === "coupon" ? "white" : "black";

        if (analyticsTab) analyticsTab.style.background = state.currentTab === "analytics" ? "#1f6463" : "#ccc";
        if (analyticsTab) analyticsTab.style.color = state.currentTab === "analytics" ? "white" : "black";
      },

      showLoginOverlay() {
        const overlay = document.getElementById("loginOverlay");
        if (overlay) overlay.style.display = "flex";
      },

      hideLoginOverlay() {
        const overlay = document.getElementById("loginOverlay");
        if (overlay) overlay.style.display = "none";
      },

      showError(message) {
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background-color: #ff6b6b;
          color: white;
          padding: 1rem;
          border-radius: 0.5rem;
          box-shadow: 0 2px 10px rgba(0,0,0,0.1);
          z-index: 1000;
          animation: slideIn 0.3s ease-out;
        `;
        errorDiv.textContent = message;
        document.body.appendChild(errorDiv);
        setTimeout(() => {
          errorDiv.style.animation = 'slideOut 0.3s ease-in';
          setTimeout(() => errorDiv.remove(), 300);
        }, 3000);
      },

      showNotification(message) {
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background-color: #1f6463;
          color: white;
          padding: 1rem;
          border-radius: 0.5rem;
          box-shadow: 0 2px 10px rgba(0,0,0,0.1);
          z-index: 1000;
          animation: slideIn 0.3s ease-out;
        `;
        notification.textContent = message;
        document.body.appendChild(notification);
        setTimeout(() => {
          notification.style.animation = 'slideOut 0.3s ease-in';
          setTimeout(() => notification.remove(), 300);
        }, 3000);
      }
    };

    // Event handlers
    const handlers = {
      async onStatusChange(event, orderId) {
        const newStatus = event.target.value;
        const previousValue = event.target.dataset.previousValue;

        try {
          // Update UI immediately
          applyStatusColor(event.target, newStatus);
          event.target.dataset.previousValue = newStatus;

          console.log(`🔄 Initiating status change for ${orderId}: ${newStatus}`);

          // Send HTTP request
          const response = await api.updateStatus(orderId, newStatus);
          console.log('✅ Status update response:', response);

          // After successful status update, refresh the entire card
          if (response && response.order) {
            try {
              // Get current filter states
              const showOld = document.getElementById("showOldToggle").checked;
              const showCompleted = document.getElementById("showCompletedToggle").checked;

              // Build query string
              const params = new URLSearchParams({
                showOld: showOld.toString(),
                showCompleted: showCompleted.toString(),
                showClaimed: (state.currentTab === "claimed").toString()
              });

              const ordersResponse = await fetch(`/dashboard/data?${params.toString()}`, {
                credentials: 'include'
              });
              
              if (!ordersResponse.ok) {
                throw new Error('Failed to fetch updated orders');
              }
              
              const orders = await ordersResponse.json();
              
              // Find the updated order
              const updatedOrder = orders.find(o => o.id === order.id);
              if (!updatedOrder) {
                console.warn('Updated order not found in response');
                return;
              }

              // Update order in state
              const orderIndex = state.allOrders.findIndex(o => o.id === order.id);
              if (orderIndex !== -1) {
                state.allOrders[orderIndex] = updatedOrder;
              }
              
              // Find the card in the DOM
              const orderCard = document.querySelector(`[data-order-id="${order.id}"]`);
              if (!orderCard) {
                console.warn('Order card not found in DOM');
                return;
              }

              // Store the current state of the details section
              const detailsSection = orderCard.querySelector('.details-section');
              const isExpanded = detailsSection?.classList.contains('visible');
              
              // Store staff notes state if expanded
              let staffNotesState = null;
              if (isExpanded) {
                const staffNotesEditor = orderCard.querySelector('.staff-notes-editor');
                if (staffNotesEditor) {
                  staffNotesState = {
                    value: staffNotesEditor.value,
                    isEditing: staffNotesEditor === document.activeElement,
                    cursorPosition: staffNotesEditor.selectionStart,
                    previousValue: staffNotesEditor.dataset.previousValue
                  };
                }
              }
              
              // Create a temporary container
              const tempContainer = document.createElement('div');
              
              // Render a single order into the temporary container
              await renderOrders([updatedOrder], isExpanded, tempContainer);
              
              // Get the newly rendered card
              const newCard = tempContainer.firstChild;
              if (!newCard) {
                console.warn('Failed to render new card');
                return;
              }
              
              // Replace the old card with the new one
              if (orderCard.parentNode) {
                orderCard.parentNode.replaceChild(newCard, orderCard);
                
                // If it was expanded and had staff notes being edited, restore that state
                if (staffNotesState) {
                  const newEditor = newCard.querySelector('.staff-notes-editor');
                  if (newEditor) {
                    newEditor.value = staffNotesState.value;
                    newEditor.dataset.previousValue = staffNotesState.previousValue;
                    
                    if (staffNotesState.isEditing) {
                      setTimeout(() => {
                        newEditor.focus();
                        newEditor.setSelectionRange(
                          staffNotesState.cursorPosition, 
                          staffNotesState.cursorPosition
                        );
                      }, 0);
                    }

                    // Update save button state
                    const saveBtn = newCard.querySelector('.save-notes-btn');
                    if (saveBtn) {
                      const hasChanges = newEditor.value !== newEditor.dataset.previousValue;
                      saveBtn.disabled = !hasChanges;
                      saveBtn.textContent = hasChanges ? "Save Notes" : "No Changes";
                      saveBtn.style.backgroundColor = hasChanges ? "#1f6463" : "#ccc";
                      saveBtn.style.cursor = hasChanges ? "pointer" : "not-allowed";
                    }
                  }
                }
                
                console.log('Successfully refreshed order card after status change');
              }
            } catch (refreshError) {
              console.error('Failed to refresh card:', refreshError);
              // Even if refresh fails, the status change was successful
              // Just update the status color
              applyStatusColor(statusDropdown, newStatus);
            }
          }
        } catch (err) {
          console.error(`❌ Failed to update status:`, err);
          // Revert on error
          statusDropdown.value = previousValue;
          applyStatusColor(statusDropdown, previousValue);
          statusDropdown.dataset.previousValue = previousValue;
          ui.showError(`Failed to update status: ${err.message}`);
        }
      },

      onSearchInput: debounce((event) => {
        filterOrders(event.target.value);
      }, SEARCH_DEBOUNCE),

      onFilterChange: async () => {
        try {
          const data = await api.fetchOrders();
          state.allOrders = Array.isArray(data) ? data : [];
          const query = document.getElementById("searchInput").value;
          filterOrders(query);
        } catch (err) {
          console.error("❌ Failed to update orders:", err);
          ui.showError("Failed to update filters");
        }
      }
    };

    // Initialize search functionality
    function initializeSearch() {
      const searchInput = document.getElementById("searchInput");
      if (!searchInput) {
        console.error('Search input not found');
        return;
      }

      // Clear any existing listeners
      const newSearchInput = searchInput.cloneNode(true);
      searchInput.parentNode.replaceChild(newSearchInput, searchInput);

      // Add new listener for immediate search
      newSearchInput.addEventListener("input", (e) => {
        const query = e.target.value;
        console.log('🔍 Search input:', query);
        filterOrders(query);
      });

      // Initialize toggle listeners
      const oldOrdersToggle = document.getElementById("showOldToggle");
      const completedToggle = document.getElementById("showCompletedToggle");
      const staffFilter = document.getElementById("staffFilter");

      // Initialize staff filter
      if (staffFilter && state.staffMembers.length > 0) {
        console.log('Initializing staff filter with members:', state.staffMembers);
        staffFilter.innerHTML = '<option value="">All Staff</option>';
        state.staffMembers.forEach(staff => {
          const option = document.createElement("option");
          option.value = staff.username;
          option.textContent = staff.displayName;
          staffFilter.appendChild(option);
        });
      }

      [oldOrdersToggle, completedToggle, staffFilter].forEach(element => {
        if (element) {
          const newElement = element.cloneNode(true);
          element.parentNode.replaceChild(newElement, element);
          newElement.addEventListener("change", async () => {
            try {
              const data = await api.fetchOrders();
              state.allOrders = Array.isArray(data) ? data : [];
              const currentQuery = document.getElementById("searchInput").value;
              filterOrders(currentQuery);
            } catch (err) {
              console.error("❌ Failed to update orders:", err);
            }
          });
        }
      });
    }

    function filterOrders(query) {
      if (!state.allOrders) {
        console.warn('No orders in state to filter');
        return;
      }

      const q = (query || '').toLowerCase().trim();
      const isSearchActive = q.length > 0;
      const staffFilter = document.getElementById("staffFilter")?.value;

      console.log(`🔍 Filtering ${state.allOrders.length} orders with query: "${q}"`);
      console.log('Current user:', state.currentUser);
      console.log('Current tab:', state.currentTab);
      console.log('Staff filter:', staffFilter);

      // First, filter based on the current tab
      let filtered = [...state.allOrders];

      // For claimed tab, show orders where user is assigned or claimed
      if (state.currentTab === "claimed") {
        filtered = filtered.filter(order => {
          const assignedStaffList = order.assigned_staff ? order.assigned_staff.split(',').map(s => s.trim()) : [];
          const isAssignedToUser = assignedStaffList.includes(state.currentUser);
          const isClaimedByUser = order.claimed_by === state.currentUser;
          const isNotCompleted = order.status?.toLowerCase() !== "completed";
          
          return (isAssignedToUser || isClaimedByUser) && isNotCompleted;
        });
        console.log('Filtered claimed orders:', filtered.length);
      }

      // Then apply search filter if present
      if (q) {
        filtered = filtered.filter(order => {
          const searchFields = {
            name: String(order.name || ''),
            email: String(order.email || ''),
            phone: String(order.phone || ''),
            id: String(order.id || ''),
            notes: String(order.notes || '')
          };
          const searchValues = Object.values(searchFields).map(v => v.toLowerCase());
          return searchValues.some(value => value.includes(q));
        });
      }

      // Apply staff filter if selected
      if (staffFilter) {
        console.log('Applying staff filter:', staffFilter);
        filtered = filtered.filter(order => {
          const assignedStaffList = order.assigned_staff ? order.assigned_staff.split(',').map(s => s.trim()) : [];
          return assignedStaffList.includes(staffFilter);
        });
      }

      console.log(`✨ Found ${filtered.length} matching orders after all filters`);

      // Clear the grid before rendering
      const grid = document.getElementById("orderGrid");
      if (grid) {
        grid.innerHTML = "";
        if (state.currentTab === "claimed") {
          renderClaimedOrders(filtered, isSearchActive);
        } else {
          renderOrders(filtered, isSearchActive);
        }
      }
    }

    // Fix the login form handler
    document.addEventListener("DOMContentLoaded", () => {
      const loginOverlay = document.getElementById("loginOverlay");
      const loginForm = document.getElementById("loginForm");
      const loginError = document.getElementById("loginError");

      // Auto-login if remembered
      if (localStorage.getItem("rememberedUser")) {
        api.checkSession()
          .then(data => {
            state.currentUser = data.username;
            ui.hideLoginOverlay();
            
            // Initialize everything after successful auto-login
            return api.getStaffList();
          })
          .then(staffList => {
            state.staffMembers = staffList;
            initializeEventListeners();
            return loadInitialOrders();
          })
          .then(() => {
            initializeSSE();
          })
          .catch(() => {
            console.warn("Failed to auto-login");
            localStorage.removeItem("rememberedUser");
          });
      }

      loginForm.addEventListener("submit", async (e) => {
        e.preventDefault();
        loginError.style.display = "none";

        const username = document.getElementById("username").value.trim().toLowerCase();
        const password = document.getElementById("password").value.trim();
        const remember = document.getElementById("rememberMe").checked;

        try {
          await api.login(username, password, remember);

          if (remember) {
            localStorage.setItem("rememberedUser", "true");
          }

          // Get session info
          const data = await api.checkSession();
          state.currentUser = data.username;

          // Initialize staff list
          try {
            console.log('🔄 Fetching staff list...');
            const staffList = await api.getStaffList();
            state.staffMembers = staffList;

            // Populate staff filter
            const staffFilter = document.getElementById("staffFilter");
            staffFilter.innerHTML = '<option value="">All Staff</option>';
            state.staffMembers.forEach(staff => {
              const option = document.createElement("option");
              option.value = staff.username;
              option.textContent = staff.displayName;
              staffFilter.appendChild(option);
            });
          } catch (err) {
            console.error('❌ Failed to load staff list:', err);
          }

          // Hide login and initialize everything
          ui.hideLoginOverlay();
          
          // Initialize event listeners AFTER login
          setTimeout(() => {
            initializeEventListeners();
            console.log('🎯 Tab event listeners initialized');
            
            // Test if tabs are clickable
            const allTab = document.getElementById("tabAll");
            const claimedTab = document.getElementById("tabClaimed");
            console.log('🔍 Tab elements found:', { allTab: !!allTab, claimedTab: !!claimedTab });
            
            if (allTab && claimedTab) {
              console.log('✅ Tab elements have onclick handlers:', { 
                allTabHandler: typeof allTab.onclick, 
                claimedTabHandler: typeof claimedTab.onclick 
              });
            }
          }, 100);
          
          await loadInitialOrders();
          initializeSSE();

        } catch (err) {
          loginError.textContent = err.message || "Login failed. Please try again.";
          loginError.style.display = "block";
          console.error("Login failed:", err);
        }
      });
    });

    // Initialize event listeners
    function initializeEventListeners() {
      console.log('🔧 Initializing event listeners...');
      
      // Tab click handlers
      const allTab = document.getElementById("tabAll");
      const claimedTab = document.getElementById("tabClaimed");
      const couponTab = document.getElementById("tabCoupon");
      const analyticsTab = document.getElementById("tabAnalytics");

      console.log('🔍 Found tab elements:', { 
        allTab: !!allTab, 
        claimedTab: !!claimedTab,
        couponTab: !!couponTab,
        analyticsTab: !!analyticsTab,
        allTabVisible: allTab ? getComputedStyle(allTab).display !== 'none' : false,
        claimedTabVisible: claimedTab ? getComputedStyle(claimedTab).display !== 'none' : false,
        couponTabVisible: couponTab ? getComputedStyle(couponTab).display !== 'none' : false,
        analyticsTabVisible: analyticsTab ? getComputedStyle(analyticsTab).display !== 'none' : false
      });

      if (allTab) {
        allTab.onclick = () => {
          console.log('🎯 All Orders tab clicked!');
          state.currentTab = "all";
          console.log('Switching to All Orders tab');
          ui.updateTabStyles();
          const query = document.getElementById("searchInput").value;
          filterOrders(query);
        };
        console.log('✅ All Orders tab onclick handler set');
      }

      if (claimedTab) {
        claimedTab.onclick = () => {
          console.log('🎯 Claimed Orders tab clicked!');
          state.currentTab = "claimed";
          console.log('Switching to Claimed Orders tab');
          ui.updateTabStyles();
          const query = document.getElementById("searchInput").value;
          filterOrders(query);
        };
        console.log('✅ Claimed Orders tab onclick handler set');
      }

      if (couponTab) {
        couponTab.onclick = () => {
          console.log('🎯 Coupon tab clicked!');
          state.currentTab = "coupon";
          console.log('Switching to Coupon tab');
          ui.updateTabStyles();
          document.getElementById("orderGrid").innerHTML = '<div style="text-align: center; padding: 2rem;">Coupon Management Coming Soon</div>';
        };
        console.log('✅ Coupon tab onclick handler set');
      }

      if (analyticsTab) {
        analyticsTab.onclick = () => {
          console.log('🎯 Analytics tab clicked!');
          state.currentTab = "analytics";
          console.log('Switching to Analytics tab');
          ui.updateTabStyles();
          document.getElementById("orderGrid").innerHTML = '<div style="text-align: center; padding: 2rem;">Analytics Dashboard Coming Soon</div>';
        };
        console.log('✅ Analytics tab onclick handler set');
      }

      // Verify that the handlers are actually set
      setTimeout(() => {
        console.log('🔍 Verifying onclick handlers after setup:', {
          allTabHandler: allTab ? typeof allTab.onclick : 'tab not found',
          claimedTabHandler: claimedTab ? typeof claimedTab.onclick : 'tab not found',
          couponTabHandler: couponTab ? typeof couponTab.onclick : 'tab not found',
          analyticsTabHandler: analyticsTab ? typeof analyticsTab.onclick : 'tab not found'
        });
      }, 50);

      // Filter listeners
      const oldOrdersToggle = document.getElementById("showOldToggle");
      const completedToggle = document.getElementById("showCompletedToggle");
      const staffFilter = document.getElementById("staffFilter");
      const searchInput = document.getElementById("searchInput");

      [oldOrdersToggle, completedToggle, staffFilter].forEach(element => {
        if (element) {
          element.onchange = handlers.onFilterChange;
        }
      });

      if (searchInput) {
        searchInput.oninput = handlers.onSearchInput;
      }

      // Window event listeners
      window.addEventListener('beforeunload', () => {
        if (window.dashboardEventSource) {
          window.dashboardEventSource.close();
        }
      });

      // Error handling for failed image loads
      document.addEventListener('error', (e) => {
        if (e.target.tagName === 'IMG') {
          e.target.style.display = 'none';
        }
      }, true);
      
      console.log('🔧 Event listeners initialization complete');
    }

    // Add back the applyStatusColor function
    function applyStatusColor(dropdown, status) {
      // Normalize the status
      const normalized = (status || 'pending').toLowerCase().replace(/\s+/g, "-");
      
      // Remove any existing status classes
      dropdown.className = 'status-dropdown';
      
      // Add the new status class
      dropdown.classList.add(`status-${normalized}`);
      
      // Apply the color based on status
      switch (normalized) {
        case 'pending':
          dropdown.style.backgroundColor = '#ff6e5f';
          dropdown.style.color = '#000';
          break;
        case 'pre-print':
          dropdown.style.backgroundColor = '#ffaea5';
          dropdown.style.color = '#000';
          break;
        case 'printing':
        case 'printing-pay-later':
          dropdown.style.backgroundColor = '#f4d03f';
          dropdown.style.color = '#000';
          break;
        case 'completed':
          dropdown.style.backgroundColor = '#2ecc71';
          dropdown.style.color = '#000';
          break;
        default:
          dropdown.style.backgroundColor = '#ff6e5f'; // Default to pending color
          dropdown.style.color = '#000';
          break;
      }
    }

    // Add back the autoEstimateOrder function
    async function autoEstimateOrder(order, card) {
      try {
        const files = await fetch(`/dashboard/files/${order.id}`).then((r) =>
          r.json()
        );
        if (!files.length) {
          console.log(`⏭️ Skipped ${order.id} — No STL files found.`);
          return;
        }

        const formData = new FormData();
        const fileNames = [];

        for (const fileUrl of files) {
          const response = await fetch(fileUrl);
          const blob = await response.blob();
          const filename = decodeURIComponent(fileUrl.split("/").pop());
          formData.append("stl", blob, filename);
          fileNames.push(filename);
        }

        const sseResponse = await fetch("/stl/upload", {
          method: "POST",
          headers: {
            Origin: "https://filamentbros.com",
          },
          body: formData,
        });

        const reader = sseResponse.body.getReader();
        const decoder = new TextDecoder("utf-8");
        let buffer = "";
        let totalEstimate = 0;
        let failedFiles = [];

        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });

          const events = buffer.split("\n\n");
          buffer = events.pop(); // Keep last incomplete

          for (const event of events) {
            if (event.startsWith("data:")) {
              const data = JSON.parse(event.replace("data:", "").trim());
              if (data.status === "success" && data.price) {
                totalEstimate += parseFloat(data.price);
              } else if (data.status === "error") {
                failedFiles.push(data.file || "Unknown file");
              }
            }
          }
        }

        if (totalEstimate > 0) {
          // Update the price in the database
          const response = await fetch("/dashboard/update-price", {
            method: "POST",
            headers: { 
              "Content-Type": "application/json",
              credentials: 'include'
            },
            body: JSON.stringify({
              orderId: order.id,
              est_price: totalEstimate.toFixed(2),
            }),
          });

          if (!response.ok) {
            throw new Error(`Failed to update price: ${response.statusText}`);
          }

          const result = await response.json();
          
          // Update the order in state
          const index = state.allOrders.findIndex(o => o.id === order.id);
          if (index !== -1) {
            state.allOrders[index] = result.order;
          }

          // Update UI
          if (card) {
            const priceLine = card.querySelector("p");
            if (priceLine) {
              priceLine.innerHTML = `<strong>Est. Price:</strong> $${totalEstimate.toFixed(2)}`;
            }
          }

          console.log(
            `✅ Updated order ${order.id} with estimate $${totalEstimate.toFixed(2)}`
          );
        }

        if (failedFiles.length > 0) {
          const message = `⚠️ Print estimate failed for: ${failedFiles.join(", ")}`;
          const existingNotes = order.order_notes ? order.order_notes + "\n\n" : "";
          const updatedNotes = existingNotes + message;

          // Update notes in database
          const notesResponse = await fetch("/dashboard/update-staff-notes", {
            method: "POST",
            headers: { 
              "Content-Type": "application/json",
              credentials: 'include'
            },
            body: JSON.stringify({
              orderId: order.id,
              staffNotes: updatedNotes,
            }),
          });

          if (!notesResponse.ok) {
            throw new Error(`Failed to update notes: ${notesResponse.statusText}`);
          }

          // Update UI immediately
          if (card) {
            const staffNotesEditor = card.querySelector(".staff-notes-editor");
            if (staffNotesEditor) {
              staffNotesEditor.value = updatedNotes;
            }
          }

          // Update order in state
          const index = state.allOrders.findIndex(o => o.id === order.id);
          if (index !== -1) {
            state.allOrders[index].order_notes = updatedNotes;
          }

          console.log(`⚠️ Added error message to staff notes for order ${order.id}`);
        }
      } catch (err) {
        console.error(`❌ Failed to auto-estimate for order ${order.id}:`, err);
        ui.showError(`Failed to estimate order: ${err.message}`);

        // Add error to staff notes
        const errorMessage = `⚠️ Auto-estimate error: ${err.message}`;
        const existingNotes = order.order_notes ? order.order_notes + "\n\n" : "";
        const updatedNotes = existingNotes + errorMessage;

        try {
          // Update notes in database
          await fetch("/dashboard/update-staff-notes", {
            method: "POST",
            headers: { 
              "Content-Type": "application/json",
              credentials: 'include'
            },
            body: JSON.stringify({
              orderId: order.id,
              staffNotes: updatedNotes,
            }),
          });

          // Update UI immediately
          if (card) {
            const staffNotesEditor = card.querySelector(".staff-notes-editor");
            if (staffNotesEditor) {
              staffNotesEditor.value = updatedNotes;
            }
          }

          // Update order in state
          const index = state.allOrders.findIndex(o => o.id === order.id);
          if (index !== -1) {
            state.allOrders[index].order_notes = updatedNotes;
          }
        } catch (notesErr) {
          console.error(`Failed to update staff notes with error: ${notesErr.message}`);
        }
      }
    }

    // Add back the renderOrders function (complete version)
    async function renderOrders(orders, expandDetails = false, container = null) {
      const grid = container || document.getElementById("orderGrid");
      if (!container) grid.innerHTML = "";

      for (const order of orders) {
        const card = document.createElement("div");
        card.className = "card";
        card.dataset.orderId = order.id;

        // Add delete button
        const deleteBtn = document.createElement("button");
        deleteBtn.className = "delete-btn";
        deleteBtn.textContent = "×";
        deleteBtn.onclick = () => showDeleteConfirmation(order.id);
        card.appendChild(deleteBtn);

        const heading = document.createElement("h2");
        heading.textContent = order.name || "Unnamed Order";
        card.appendChild(heading);

        // Add submission date/time
        const submissionTime = document.createElement("div");
        submissionTime.className = "submission-time";
        const submittedAt = order.submitted_at ? new Date(order.submitted_at) : null;
        submissionTime.textContent = `Submitted: ${submittedAt ? formatDate(submittedAt) : 'Unknown'}`;
        submissionTime.title = `Submitted: ${submittedAt ? submittedAt.toLocaleString() : 'Unknown'}`;
        card.appendChild(submissionTime);

        const statusOptions = [
          "pending",
          "pre print",
          "printing",
          "printing pay later",
          "completed",
        ];
        const currentStatus = (order.status || "pending").toLowerCase();

        const statusDropdown = document.createElement("select");
        statusDropdown.className = "status-dropdown";
        statusDropdown.dataset.previousValue = currentStatus;

        // Create and append status options
        statusOptions.forEach((status) => {
          const option = document.createElement("option");
          option.value = status;
          option.textContent = status
            .split(" ")
            .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
            .join(" ");
          if (status.toLowerCase() === currentStatus.toLowerCase()) {
            option.selected = true;
          }
          statusDropdown.appendChild(option);
        });

        // Apply initial status color
        applyStatusColor(statusDropdown, currentStatus);

        // Single event handler for status changes
        statusDropdown.addEventListener("change", async () => {
          const newStatus = statusDropdown.value;
          const previousValue = statusDropdown.dataset.previousValue;

          try {
            // Update UI immediately
            applyStatusColor(statusDropdown, newStatus);
            statusDropdown.dataset.previousValue = newStatus;

            console.log(`🔄 Initiating status change for ${order.id}: ${newStatus}`);

            // Send HTTP request
            const response = await api.updateStatus(order.id, newStatus);
            console.log('✅ Status update response:', response);

            // Update order in state
            if (response && response.order) {
              const orderIndex = state.allOrders.findIndex(o => o.id === order.id);
              if (orderIndex !== -1) {
                state.allOrders[orderIndex] = response.order;
              }
            }
          } catch (err) {
            console.error(`❌ Failed to update status:`, err);
            // Revert on error
            statusDropdown.value = previousValue;
            applyStatusColor(statusDropdown, previousValue);
            statusDropdown.dataset.previousValue = previousValue;
            ui.showError(`Failed to update status: ${err.message}`);
          }
        });

        const statusWrapper = document.createElement("div");
        statusWrapper.className = "status-wrapper";
        statusWrapper.appendChild(statusDropdown);
        card.appendChild(statusWrapper);

        // Show estimated price right under heading
        const price = document.createElement("p");
        price.style.margin = "0";
        price.innerHTML = `<strong>Est. Price:</strong> ${order.est_price ? `$${order.est_price.toFixed(2)}` : "—"}`;
        card.appendChild(price);

        const toggleBtn = document.createElement("button");
        toggleBtn.className = "details-toggle";
        toggleBtn.textContent = "Show Details ▼";
        card.appendChild(toggleBtn);

        const detailsSection = document.createElement("div");
        detailsSection.className = "details-section";

        // Create details table
        const table = document.createElement("table");
        table.className = "details-table";

        // Add assigned price row
        const assignedPriceRow = document.createElement("tr");
        const assignedPriceCell = document.createElement("td");
        assignedPriceCell.textContent = "Assigned Price:";
        const assignedPriceContentCell = document.createElement("td");
        
        const priceWrapper = document.createElement("div");
        priceWrapper.className = "price-input-wrapper";
        
        const dollarSign = document.createElement("span");
        dollarSign.className = "dollar-sign";
        dollarSign.textContent = "$";
        
        const assignedPriceInput = document.createElement("input");
        assignedPriceInput.type = "number";
        assignedPriceInput.step = "0.01";
        assignedPriceInput.min = "0";
        assignedPriceInput.className = "assigned-price-input";
        assignedPriceInput.value = order.assigned_price || '';
        assignedPriceInput.placeholder = "Enter price...";
        assignedPriceInput.dataset.previousValue = order.assigned_price || '';
        
        const savePriceBtn = document.createElement("button");
        savePriceBtn.className = "save-price-btn";
        savePriceBtn.textContent = "Save Price";
        savePriceBtn.disabled = true;

        priceWrapper.appendChild(dollarSign);
        priceWrapper.appendChild(assignedPriceInput);
        priceWrapper.appendChild(savePriceBtn);

        // Handle changes to assigned price
        assignedPriceInput.addEventListener('input', () => {
          const currentValue = assignedPriceInput.value;
          const previousValue = assignedPriceInput.dataset.previousValue;
          const hasChanges = currentValue !== previousValue;
          
          savePriceBtn.disabled = !hasChanges;
          savePriceBtn.style.backgroundColor = hasChanges ? "#1f6463" : "#ccc";
          savePriceBtn.style.cursor = hasChanges ? "pointer" : "not-allowed";
        });

        // Handle save button click
        savePriceBtn.addEventListener('click', async () => {
          try {
            savePriceBtn.disabled = true;
            savePriceBtn.textContent = "Saving...";
            
            const response = await fetch("/dashboard/update-assigned-price", {
              method: "POST",
              headers: { 
                "Content-Type": "application/json",
                credentials: 'include'
              },
              body: JSON.stringify({
                orderId: order.id,
                assignedPrice: parseFloat(assignedPriceInput.value)
              })
            });

            if (!response.ok) {
              throw new Error('Failed to save assigned price');
            }

            const data = await response.json();
            
            // Update the input with the new value
            assignedPriceInput.value = data.order.assigned_price || '';
            assignedPriceInput.dataset.previousValue = data.order.assigned_price || '';
            
            // Update button state
            savePriceBtn.textContent = "Save Price";
            savePriceBtn.disabled = true;
            savePriceBtn.style.backgroundColor = "#ccc";
            savePriceBtn.style.cursor = "not-allowed";

            // Show success notification
            ui.showNotification('Assigned price updated successfully');

          } catch (err) {
            console.error('Failed to save assigned price:', err);
            ui.showError('Failed to save assigned price');
            
            savePriceBtn.textContent = "Save Price";
            savePriceBtn.disabled = false;
            savePriceBtn.style.backgroundColor = "#1f6463";
            savePriceBtn.style.cursor = "pointer";
          }
        });

        // Add Ctrl+Enter / Cmd+Enter save shortcut
        assignedPriceInput.addEventListener('keydown', (e) => {
          if ((e.ctrlKey || e.metaKey) && e.key === 'Enter' && !savePriceBtn.disabled) {
            e.preventDefault();
            savePriceBtn.click();
          }
        });

        assignedPriceContentCell.appendChild(priceWrapper);
        assignedPriceRow.appendChild(assignedPriceCell);
        assignedPriceRow.appendChild(assignedPriceContentCell);
        table.appendChild(assignedPriceRow);

        // Add divider
        const dividerRow = document.createElement("tr");
        const dividerCell = document.createElement("td");
        dividerCell.colSpan = 2;
        const divider = document.createElement("div");
        divider.className = "details-divider";
        dividerCell.appendChild(divider);
        dividerRow.appendChild(dividerCell);
        table.appendChild(dividerRow);

        // Add email row
        const emailRow = document.createElement("tr");
        emailRow.innerHTML = `
          <td>Email:</td>
          <td>${order.email || '—'}</td>
        `;
        table.appendChild(emailRow);

        // Add phone row
        const phoneRow = document.createElement("tr");
        phoneRow.innerHTML = `
          <td>Phone:</td>
          <td>${order.phone || '—'}</td>
        `;
        table.appendChild(phoneRow);

        // Add customer notes
        const customerNotesRow = document.createElement("tr");
        customerNotesRow.innerHTML = `
          <td>Customer Notes:</td>
          <td>${order.notes || '—'}</td>
        `;
        table.appendChild(customerNotesRow);

        // Add staff notes with edit functionality
        const staffNotesRow = document.createElement("tr");
        const staffNotesCell = document.createElement("td");
        staffNotesCell.textContent = "Staff Notes:";
        const staffNotesContentCell = document.createElement("td");
        
        // Create staff notes editor
        const staffNotesEditor = document.createElement("textarea");
        staffNotesEditor.className = "staff-notes-editor";
        staffNotesEditor.value = order.order_notes || '';
        staffNotesEditor.dataset.previousValue = order.order_notes || '';
        staffNotesEditor.placeholder = "Add staff notes here...";
        staffNotesEditor.spellcheck = true;
        staffNotesEditor.style.resize = "vertical";
        
        const saveNotesBtn = document.createElement("button");
        saveNotesBtn.className = "action-button save-notes-btn";
        saveNotesBtn.textContent = "Save Notes";
        saveNotesBtn.disabled = true;

        // Handle changes to staff notes
        staffNotesEditor.addEventListener('input', () => {
          const currentValue = staffNotesEditor.value;
          const previousValue = staffNotesEditor.dataset.previousValue || '';
          const hasChanges = currentValue !== previousValue;
          
          saveNotesBtn.disabled = !hasChanges;
          
          // Update button text and style based on state
          if (hasChanges) {
            saveNotesBtn.textContent = "Save Notes";
            saveNotesBtn.style.backgroundColor = "#1f6463";
            saveNotesBtn.style.cursor = "pointer";
          } else {
            saveNotesBtn.textContent = "No Changes";
            saveNotesBtn.style.backgroundColor = "#ccc";
            saveNotesBtn.style.cursor = "not-allowed";
          }
        });

        // Handle paste and cut events
        ['paste', 'cut'].forEach(eventName => {
          staffNotesEditor.addEventListener(eventName, () => {
            setTimeout(() => staffNotesEditor.dispatchEvent(new Event('input')), 0);
          });
        });

        // Handle save button click
        saveNotesBtn.addEventListener('click', () => {
          if (staffNotesEditor.value !== staffNotesEditor.dataset.previousValue) {
            saveStaffNotes(order.id, staffNotesEditor.value, staffNotesEditor, saveNotesBtn);
          }
        });

        // Also allow saving with Ctrl+Enter or Cmd+Enter
        staffNotesEditor.addEventListener('keydown', (e) => {
          if ((e.ctrlKey || e.metaKey) && e.key === 'Enter' && !saveNotesBtn.disabled) {
            e.preventDefault();
            saveNotesBtn.click();
          }
        });

        staffNotesContentCell.appendChild(staffNotesEditor);
        staffNotesContentCell.appendChild(saveNotesBtn);
        staffNotesRow.appendChild(staffNotesCell);
        staffNotesRow.appendChild(staffNotesContentCell);
        table.appendChild(staffNotesRow);

        // Add staff selection container
        const staffContainer = document.createElement("div");
        staffContainer.className = "staff-selection-container";

        const staffLabel = document.createElement("span");
        staffLabel.innerHTML = "Assigned Staff";
        staffLabel.style.cssText = "color: #666; font-size: 0.9rem; display: block; margin-bottom: 0.25rem;";
        staffContainer.appendChild(staffLabel);

        // Create container for staff tags
        const staffTagsGrid = document.createElement("div");
        staffTagsGrid.className = "staff-tags-grid";

        // Get current assigned staff
        const currentStaff = order.assigned_staff ? order.assigned_staff.split(',') : [];

        // Create clickable tags for each staff member
        state.staffMembers.forEach(staff => {
          const tag = createStaffTag(staff, order, staffTagsGrid);
          staffTagsGrid.appendChild(tag);
        });

        staffContainer.appendChild(staffTagsGrid);

        // Add to the table
        const staffRow = document.createElement("tr");
        staffRow.innerHTML = `<td>Staff:</td><td></td>`;
        staffRow.cells[1].appendChild(staffContainer);
        table.appendChild(staffRow);

        detailsSection.appendChild(table);
        card.appendChild(detailsSection);

        const idLine = document.createElement("div");
        idLine.className = "order-id";
        idLine.textContent = `Order ID: ${order.id}`;
        card.appendChild(idLine);

        toggleBtn.onclick = () => {
          const visible = detailsSection.classList.toggle("visible");
          toggleBtn.textContent = visible ? "Hide ▲" : "Show Details ▼";
        };

        // Expand by default if search is active
        if (expandDetails) {
          detailsSection.classList.add("visible");
          toggleBtn.textContent = "Hide ▲";
        }

        fetch(`/dashboard/files/${order.id}`)
          .then((res) => res.json())
          .then((files) => {
            if (files.length > 0) {
              const stlTitle = document.createElement("p");
              stlTitle.className = "stl-header";
              stlTitle.textContent = "STL Files:";
              detailsSection.appendChild(stlTitle);

              const list = document.createElement("ul");
              list.className = "stl-list";

              files.forEach((fileUrl) => {
                const fullFilename = decodeURIComponent(fileUrl.split("/").pop());
                const downloadUrl = `/dashboard/fileserve/${encodeURIComponent(fullFilename)}`;
                const filename = fullFilename.replace(/^order[_-]?[a-zA-Z0-9]+[_-]/i, "");

                const li = document.createElement("li");
                li.innerHTML = `
                  <a href="${downloadUrl}" title="${filename}" class="stl-link" download target="_blank">
                    ${filename}
                  </a>`;
                list.appendChild(li);
              });

              detailsSection.appendChild(list);

              if (files.length > 0) {
                const downloadAll = document.createElement("a");
                downloadAll.href = `/dashboard/download-all/${order.id}`;
                downloadAll.className = "download-all-btn";
                downloadAll.textContent = "📦 Download All";
                detailsSection.appendChild(downloadAll);
              }
            }

            const isClaimed = order.claimed_by !== null;
            const isCompleted = order.status?.toLowerCase() === "completed";
            const isClaimedByCurrentUser = order.claimed_by === state.currentUser;

            // Show claim/unclaim buttons in both tabs
            if (isCompleted) {
              const completedLabel = document.createElement("button");
              completedLabel.textContent = "Completed";
              completedLabel.disabled = true;
              completedLabel.className = "action-button";
              completedLabel.style.backgroundColor = "#999";
              completedLabel.style.color = "#666";
              completedLabel.style.cursor = "not-allowed";
              card.appendChild(completedLabel);
            } else {
              if (isClaimedByCurrentUser) {
                card.appendChild(createUnclaimButton(order));
              } else if (state.currentTab === "all") { // Only show claim button in "all" tab
                const claimBtn = document.createElement("button");
                claimBtn.textContent = isClaimed ? `Claimed by ${order.claimed_by}` : "Claim Order";
                claimBtn.disabled = isClaimed;
                claimBtn.className = "action-button";
                claimBtn.style.backgroundColor = isClaimed ? '#999' : '#ccc';
                claimBtn.style.cursor = isClaimed ? "not-allowed" : "pointer";

                if (!isClaimed) {
                  claimBtn.addEventListener('click', async () => {
                    try {
                      claimBtn.textContent = "Claiming...";
                      claimBtn.disabled = true;
                      claimBtn.classList.add('claiming');

                      const response = await api.claimOrder(order.id);
                      
                      if (response && response.order) {
                        Object.assign(order, response.order);
                        updateStaffTagsForOrder(card, [state.currentUser]);
                        claimBtn.replaceWith(createUnclaimButton(order));
                      }
                    } catch (err) {
                      console.error(`Failed to claim order ${order.id}:`, err);
                      ui.showError(err.message || "Failed to claim order");
                      claimBtn.textContent = 'Claim Order';
                      claimBtn.disabled = false;
                      claimBtn.classList.remove('claiming');
                    }
                  });
                }

                card.appendChild(claimBtn);
              }
            }
          })
          .catch((err) => {
            console.error(`❌ Failed to load STL files for ${order.id}`, err);
          });

        grid.appendChild(card);

        // Only auto-estimate if there's no price and no failed estimate note
        if (!order.est_price && 
            !(order.order_notes && order.order_notes.includes("Print estimate failed"))) {
          console.log(`🔄 Running auto-estimate for order ${order.id} - no existing price found`);
          autoEstimateOrder(order, card);
        } else {
          console.log(`⏭️ Skipping auto-estimate for order ${order.id} - price already exists: $${order.est_price}`);
        }
      }
    }

    // Add back the renderClaimedOrders function
    async function renderClaimedOrders(orders, expandDetails = false) {
      const grid = document.getElementById("orderGrid");
      if (!grid) {
        console.error('Order grid not found');
        return;
      }

      // Filter for orders that are either claimed by current user OR where user is in assigned staff
      const claimedOrders = orders.filter(order => {
        const assignedStaffList = order.assigned_staff ? order.assigned_staff.split(',').map(s => s.trim()) : [];
        const isAssignedToUser = assignedStaffList.includes(state.currentUser);
        const isClaimedByUser = order.claimed_by === state.currentUser;
        const isNotCompleted = order.status?.toLowerCase() !== "completed";
        
        console.log(`Checking order ${order.id}:`, {
          assignedStaff: order.assigned_staff,
          assignedStaffList,
          isAssignedToUser,
          isClaimedByUser,
          isNotCompleted,
          currentUser: state.currentUser
        });
        
        return (isAssignedToUser || isClaimedByUser) && isNotCompleted;
      });

      console.log(`📋 Rendering ${claimedOrders.length} claimed orders for user ${state.currentUser}`);

      // Clear the grid if not already done
      if (!grid.querySelector('.card')) {
        grid.innerHTML = '';
      }

      // Use the existing renderOrders function to render the filtered orders
      await renderOrders(claimedOrders, expandDetails, grid);
    }

    // Add back the initializeSSE function
    function initializeSSE() {
      let retryCount = 0;
      const maxRetries = 5;
      const retryDelay = 1000;

      function connect() {
        const eventSource = new EventSource('/dashboard/updates', { withCredentials: true });

        eventSource.onopen = () => {
          console.log('✅ SSE connection established');
          retryCount = 0;
        };

        eventSource.onerror = (error) => {
          console.error('❌ SSE connection error:', error);
          eventSource.close();

          if (retryCount < maxRetries) {
            retryCount++;
            setTimeout(connect, retryDelay * retryCount);
          } else {
            console.error('❌ Max SSE reconnection attempts reached');
            ui.showError('Lost connection to server. Please refresh the page.');
          }
        };

        // Store the eventSource in window for cleanup
        window.dashboardEventSource = eventSource;

        // Handle order updates
        eventSource.addEventListener('orderUpdate', (e) => {
          try {
            const update = JSON.parse(e.data);
            console.log('📦 Received order update:', update);

            if (update.type === 'delete') {
              // Remove from state
              state.allOrders = state.allOrders.filter(order => order.id !== update.orderId);

              // Find and remove the card with animation
              const card = document.querySelector(`[data-order-id="${update.orderId}"]`);
              if (card) {
                card.style.transition = "all 0.3s ease";
                card.style.opacity = "0";
                card.style.transform = "scale(0.9)";
                setTimeout(() => card.remove(), 300);
              }

              // Show notification if deleted by someone else
              if (update.deletedBy !== state.currentUser) {
                ui.showNotification(`Order ${update.orderId} was deleted by ${update.deletedBy}`);
              }
            } else {
              // Handle new orders
              if (update.type === 'new') {
                console.log('🆕 New order received:', update.order);
                
                // Add to state if not already present
                const exists = state.allOrders.some(order => order.id === update.order.id);
                if (!exists) {
                  state.allOrders.unshift(update.order);
                  
                  // Show notification
                  ui.showNotification('New order received!');
                  
                  // Refresh the view
                  const query = document.getElementById("searchInput").value;
                  filterOrders(query);
                }
              } else {
                // Handle updates to existing orders
                console.log(`🔄 Processing ${update.type} update for order ${update.order.id}`);
                
                // Show notifications for claim/unclaim events
                if (update.type === 'claim' && update.order.claimed_by !== state.currentUser) {
                  ui.showNotification(`Order ${update.order.id} was claimed by ${update.order.claimed_by}`);
                } else if (update.type === 'unclaim' && update.order.claimed_by === null) {
                  ui.showNotification(`Order ${update.order.id} was unclaimed`);
                }

                // Find the card in the DOM
                const orderCard = document.querySelector(`[data-order-id="${update.order.id}"]`);
                if (!orderCard) {
                  console.log(`Card not found for order ${update.order.id}, refreshing view...`);
                  const query = document.getElementById("searchInput").value;
                  filterOrders(query);
                  return;
                }

                // Store the current state of the details section and staff notes
                const detailsSection = orderCard.querySelector('.details-section');
                const isExpanded = detailsSection?.classList.contains('visible');
                
                // Store staff notes state if expanded
                let staffNotesState = null;
                if (isExpanded) {
                  const staffNotesEditor = orderCard.querySelector('.staff-notes-editor');
                  if (staffNotesEditor) {
                    staffNotesState = {
                      value: staffNotesEditor.value,
                      isEditing: staffNotesEditor === document.activeElement,
                      cursorPosition: staffNotesEditor.selectionStart,
                      previousValue: staffNotesEditor.dataset.previousValue
                    };
                  }
                }

                // Update order in state
                const index = state.allOrders.findIndex(order => order.id === update.order.id);
                if (index !== -1) {
                  state.allOrders[index] = update.order;
                } else {
                  state.allOrders.unshift(update.order);
                }

                // Handle claimed tab visibility
                if (state.currentTab === "claimed") {
                  const assignedStaffList = update.order.assigned_staff ? update.order.assigned_staff.split(',') : [];
                  const shouldBeVisible = (
                    (update.order.claimed_by === state.currentUser || assignedStaffList.includes(state.currentUser)) &&
                    update.order.status?.toLowerCase() !== "completed"
                  );
                  
                  if (!shouldBeVisible) {
                    console.log(`Removing card ${update.order.id} from claimed view`);
                    orderCard.style.transition = "all 0.3s ease";
                    orderCard.style.opacity = "0";
                    orderCard.style.transform = "scale(0.9)";
                    setTimeout(() => {
                      if (orderCard.isConnected) {
                        orderCard.remove();
                      }
                    }, 300);
                    return;
                  }
                }

                // Create a temporary container for the new card
                const tempContainer = document.createElement('div');
                
                // Render a single order into the temporary container
                renderOrders([update.order], isExpanded, tempContainer);
                
                // Get the newly rendered card
                const newCard = tempContainer.firstChild;
                if (!newCard) {
                  console.warn('Failed to render new card');
                  return;
                }
                
                // Replace the old card with the new one
                if (orderCard.parentNode) {
                  orderCard.parentNode.replaceChild(newCard, orderCard);
                  
                  // If it was expanded and had staff notes being edited, restore that state
                  if (staffNotesState) {
                    const newEditor = newCard.querySelector('.staff-notes-editor');
                    if (newEditor) {
                      // Only restore the user's edits if they were actively editing
                      // Otherwise use the new value from the server
                      if (staffNotesState.isEditing) {
                        newEditor.value = staffNotesState.value;
                        newEditor.dataset.previousValue = staffNotesState.previousValue;
                        
                        setTimeout(() => {
                          newEditor.focus();
                          newEditor.setSelectionRange(
                            staffNotesState.cursorPosition, 
                            staffNotesState.cursorPosition
                          );
                        }, 0);

                        // Update save button state
                        const saveBtn = newCard.querySelector('.save-notes-btn');
                        if (saveBtn) {
                          const hasChanges = newEditor.value !== newEditor.dataset.previousValue;
                          saveBtn.disabled = !hasChanges;
                          saveBtn.textContent = hasChanges ? "Save Notes" : "No Changes";
                          saveBtn.style.backgroundColor = hasChanges ? "#1f6463" : "#ccc";
                          saveBtn.style.cursor = hasChanges ? "pointer" : "not-allowed";
                        }
                      }
                    }
                  }
                  
                  console.log('Successfully refreshed order card after remote update');
                }
              }
            }
          } catch (err) {
            console.error('❌ Failed to process order update:', err);
            ui.showError('Failed to process update');
          }
        });

        return eventSource;
      }

      connect();
    }

    // Start the app
    async function initialize() {
      try {
        // Check session first
        const sessionData = await api.checkSession();
        if (sessionData.username) {
          state.currentUser = sessionData.username;
          ui.hideLoginOverlay();
          
          // Get staff list
          console.log('🔄 Fetching staff list...');
          const staffList = await api.getStaffList();
          state.staffMembers = staffList;
          console.log('✅ Staff list loaded:', staffList);
          
          // Initialize UI components
          setTimeout(() => {
            initializeEventListeners();
            console.log('🎯 Dashboard initialized with tab listeners');
            
            // Initialize staff filter dropdown
            const staffFilter = document.getElementById("staffFilter");
            if (staffFilter) {
              staffFilter.innerHTML = '<option value="">All Staff</option>';
              state.staffMembers.forEach(staff => {
                const option = document.createElement("option");
                option.value = staff.username;
                option.textContent = staff.displayName;
                staffFilter.appendChild(option);
              });
              console.log('✅ Staff filter dropdown populated');
            }
          }, 100);
          
          await loadInitialOrders();
          initializeSSE();
        } else {
          ui.showLoginOverlay();
        }
      } catch (err) {
        console.error('Failed to initialize:', err);
        ui.showLoginOverlay();
      }
    }

    // Start the app
    document.addEventListener("DOMContentLoaded", initialize);

    // Helper function to create unclaim button
    function createUnclaimButton(order, claimTimestamp = Date.now()) {
      const unclaimBtn = document.createElement('button');
      unclaimBtn.textContent = 'Unclaim';
      unclaimBtn.className = 'action-button';

      let isUnclaiming = false;

      unclaimBtn.addEventListener('click', async () => {
        if (isUnclaiming) return;
        
        try {
          isUnclaiming = true;
          unclaimBtn.textContent = 'Unclaiming...';
          unclaimBtn.disabled = true;
          unclaimBtn.classList.add('unclaiming');

          // Get the card element BEFORE making the API call
          const card = unclaimBtn.closest('.card');
          if (!card) {
            throw new Error('Could not find order card');
          }

          const response = await api.unclaimOrder(order.id);
          
          // Update the order object with the response
          if (response && response.order) {
            Object.assign(order, response.order);
          }

          // Handle card visibility based on current tab
          if (state.currentTab === "claimed") {
            // In claimed tab, smoothly remove the card
            card.style.transition = "all 0.3s ease";
            card.style.opacity = "0";
            card.style.transform = "scale(0.9)";
            setTimeout(() => card.remove(), 300);
          } else {
            // In all tab, update the card
            const statusDropdown = card.querySelector('.status-dropdown');
            if (statusDropdown) {
              const newStatus = order.status || 'pending';
              statusDropdown.value = newStatus;
              statusDropdown.dataset.previousValue = newStatus;
              applyStatusColor(statusDropdown, newStatus);
            }

            // Update staff tags
            const assignedStaff = order.assigned_staff ? order.assigned_staff.split(',') : [];
            updateStaffTagsForOrder(card, assignedStaff);

            // Replace unclaim button with claim button
            const newClaimBtn = document.createElement('button');
            newClaimBtn.textContent = 'Claim Order';
            newClaimBtn.className = 'action-button';
            
            // Add claim functionality
            newClaimBtn.addEventListener('click', async () => {
              try {
                newClaimBtn.textContent = 'Claiming...';
                newClaimBtn.disabled = true;
                newClaimBtn.classList.add('claiming');

                const response = await api.claimOrder(order.id);
                
                if (response && response.order) {
                  Object.assign(order, response.order);
                  
                  // Update the status dropdown
                  const statusDropdown = card.querySelector('.status-dropdown');
                  if (statusDropdown) {
                    const newStatus = response.order.status || 'pending';
                    statusDropdown.value = newStatus;
                    statusDropdown.dataset.previousValue = newStatus;
                    applyStatusColor(statusDropdown, newStatus);
                  }
                  
                  // Update staff tags
                  updateStaffTagsForOrder(card, [state.currentUser]);
                  
                  // Replace with unclaim button
                  newClaimBtn.replaceWith(createUnclaimButton(order));
                }
              } catch (err) {
                console.error(`Failed to claim order ${order.id}:`, err);
                ui.showError(err.message || "Failed to claim order");
                newClaimBtn.textContent = 'Claim Order';
                newClaimBtn.disabled = false;
                newClaimBtn.classList.remove('claiming');
              }
            });

            unclaimBtn.replaceWith(newClaimBtn);
          }
        } catch (err) {
          console.error(`Failed to unclaim order ${order.id}:`, err);
          ui.showError(err.message || "Failed to unclaim order");
          unclaimBtn.textContent = 'Unclaim';
          unclaimBtn.disabled = false;
          unclaimBtn.classList.remove('unclaiming');
        } finally {
          isUnclaiming = false;
        }
      });

      return unclaimBtn;
    }

    // Function to update staff tags based on assigned staff
    function updateStaffTagsForOrder(orderCard, assignedStaff) {
      console.log('🔄 Updating staff tags:', { orderId: orderCard.dataset.orderId, assignedStaff });
      
      const staffTags = orderCard.querySelectorAll('.staff-tag');
      staffTags.forEach(tag => {
        const staffMember = state.staffMembers.find(s => s.displayName === tag.textContent);
        if (staffMember) {
          const isSelected = assignedStaff.includes(staffMember.username);
          tag.classList.toggle('selected', isSelected);
          console.log(`Staff tag ${staffMember.username}: ${isSelected ? 'selected' : 'unselected'}`);
        }
      });
    }

    // Update the staff tag click handler
    function createStaffTag(staff, order, staffTagsGrid) {
      const tag = document.createElement("div");
      tag.className = "staff-tag";
      tag.textContent = staff.displayName;
      
      // Set initial selection state
      const currentStaff = order.assigned_staff ? order.assigned_staff.split(',').map(s => s.trim()) : [];
      if (currentStaff.includes(staff.username)) {
        tag.classList.add("selected");
      }
      
      // Handle click events
      tag.addEventListener("click", async () => {
        try {
          // Toggle selection visually first
          const isSelected = tag.classList.toggle("selected");
          
          // Get all selected staff
          const selectedStaff = Array.from(staffTagsGrid.children)
            .filter(tag => tag.classList.contains("selected"))
            .map(tag => {
              const staffMember = state.staffMembers.find(s => s.displayName === tag.textContent);
              return staffMember ? staffMember.username : null;
            })
            .filter(Boolean);
          
          // Make the API call
          const response = await fetch("/dashboard/assign-staff", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            credentials: 'include',
            body: JSON.stringify({ 
              orderId: order.id, 
              staffName: selectedStaff.join(',') 
            })
          });
          
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          
          const result = await response.json();
          console.log(`✅ Staff assignment API response:`, result);
          
          if (result && result.order) {
            // Update the order object
            Object.assign(order, result.order);
            console.log(`Updated order object with new staff: ${result.order.assigned_staff}`);
          }
        } catch (err) {
          // Revert the selection on error
          tag.classList.toggle("selected");
          console.error(`❌ Failed to update staff:`, err);
          ui.showError(err.message || "Failed to update staff assignment");
        }
      });
      
      return tag;
    }

    // Function to update staff tags based on assigned staff
    function updateStaffTagsForOrder(orderCard, assignedStaff) {
      console.log('🔄 Updating staff tags for order:', { 
        orderId: orderCard.dataset.orderId, 
        assignedStaff 
      });
      
      const staffTags = orderCard.querySelectorAll('.staff-tag');
      let updatedCount = 0;
      
      staffTags.forEach(tag => {
        const staffMember = state.staffMembers.find(s => s.displayName === tag.textContent);
        if (staffMember) {
          const isSelected = assignedStaff.includes(staffMember.username);
          const wasSelected = tag.classList.contains('selected');
          
          if (isSelected !== wasSelected) {
            tag.classList.toggle('selected', isSelected);
            updatedCount++;
            console.log(`Updated staff tag ${staffMember.username}: ${wasSelected} -> ${isSelected}`);
          }
        }
      });
      
      console.log(`Updated ${updatedCount} staff tags`);
    }

    // Update the handleOrderUpdate function to better handle staff updates
    function handleOrderUpdate(updatedOrder) {
      console.log('🔄 Processing order update:', updatedOrder);

      // Update order in state
      const index = state.allOrders.findIndex(order => order.id === updatedOrder.id);
      if (index !== -1) {
        state.allOrders[index] = updatedOrder;
      } else {
        state.allOrders.unshift(updatedOrder);
      }

      // Get the existing card
      const orderCard = document.querySelector(`[data-order-id="${updatedOrder.id}"]`);
      if (!orderCard) {
        console.log(`Card not found for order ${updatedOrder.id}, refreshing view...`);
        const query = document.getElementById("searchInput").value;
        filterOrders(query);
        return;
      }

      // Handle claimed tab visibility
      if (state.currentTab === "claimed") {
        const assignedStaffList = updatedOrder.assigned_staff ? updatedOrder.assigned_staff.split(',') : [];
        const shouldBeVisible = (
          (updatedOrder.claimed_by === state.currentUser || assignedStaffList.includes(state.currentUser)) &&
          updatedOrder.status?.toLowerCase() !== "completed"
        );
        
        if (!shouldBeVisible) {
          console.log(`Removing card ${updatedOrder.id} from claimed view`);
          orderCard.style.transition = "all 0.3s ease";
          orderCard.style.opacity = "0";
          orderCard.style.transform = "scale(0.9)";
          setTimeout(() => {
            if (orderCard.isConnected) {
              orderCard.remove();
            }
          }, 300);
          return;
        }
      }

      // Update status dropdown
      const statusDropdown = orderCard.querySelector('.status-dropdown');
      if (statusDropdown) {
        const newStatus = updatedOrder.status || 'pending';
        console.log(`Updating status for order ${updatedOrder.id} to:`, newStatus);
        statusDropdown.value = newStatus;
        statusDropdown.dataset.previousValue = newStatus;
        applyStatusColor(statusDropdown, newStatus);
      }

      // Update claim/unclaim button
      const actionBtn = orderCard.querySelector('.action-button:not(.save-notes-btn)');
      if (actionBtn) {
        if (updatedOrder.status?.toLowerCase() === 'completed') {
          // Replace with completed label
          const completedLabel = document.createElement("button");
          completedLabel.textContent = "Completed";
          completedLabel.disabled = true;
          completedLabel.className = "action-button";
          completedLabel.style.backgroundColor = "#999";
          completedLabel.style.color = "#666";
          completedLabel.style.cursor = "not-allowed";
          actionBtn.replaceWith(completedLabel);
        } else if (updatedOrder.claimed_by === state.currentUser) {
          // Replace with unclaim button if not already an unclaim button
          if (!actionBtn.textContent.includes('Unclaim')) {
            actionBtn.replaceWith(createUnclaimButton(updatedOrder));
          }
        } else {
          // Update or replace with claim button
          const newClaimBtn = document.createElement('button');
          newClaimBtn.className = 'action-button';
          
          if (updatedOrder.claimed_by) {
            newClaimBtn.textContent = `Claimed by ${updatedOrder.claimed_by}`;
            newClaimBtn.disabled = true;
            newClaimBtn.style.backgroundColor = '#999';
            newClaimBtn.style.cursor = 'not-allowed';
          } else {
            newClaimBtn.textContent = 'Claim Order';
            newClaimBtn.addEventListener('click', async () => {
              try {
                newClaimBtn.textContent = 'Claiming...';
                newClaimBtn.disabled = true;
                newClaimBtn.classList.add('claiming');

                const response = await api.claimOrder(updatedOrder.id);
                
                if (response && response.order) {
                  Object.assign(updatedOrder, response.order);
                  updateStaffTagsForOrder(orderCard, [state.currentUser]);
                  newClaimBtn.replaceWith(createUnclaimButton(updatedOrder));
                }
              } catch (err) {
                console.error(`Failed to claim order ${updatedOrder.id}:`, err);
                ui.showError(err.message || "Failed to claim order");
                newClaimBtn.textContent = 'Claim Order';
                newClaimBtn.disabled = false;
                newClaimBtn.classList.remove('claiming');
              }
            });
          }
          
          actionBtn.replaceWith(newClaimBtn);
        }
      }

      // Update staff tags
      const assignedStaff = updatedOrder.assigned_staff ? updatedOrder.assigned_staff.split(',') : [];
      updateStaffTagsForOrder(orderCard, assignedStaff);

      // Update other card elements
      updateCardElements(orderCard, updatedOrder);

      // Update staff notes if they exist
      let staffNotesEditor = orderCard.querySelector(".staff-notes-editor");
      let saveNotesBtn = orderCard.querySelector(".save-notes-btn");
      
      if (staffNotesEditor && updatedOrder.order_notes !== undefined) {
        // Only update if the editor is not currently focused (being edited)
        const isEditorFocused = staffNotesEditor === document.activeElement;
        const currentValue = staffNotesEditor.value;
        
        if (!isEditorFocused) {
          staffNotesEditor.value = updatedOrder.order_notes || '';
          staffNotesEditor.dataset.previousValue = updatedOrder.order_notes || '';
        }

        // Ensure the editor remains editable
        staffNotesEditor.disabled = false;
        staffNotesEditor.readOnly = false;

        // Reset save button state
        if (saveNotesBtn) {
          const hasChanges = currentValue !== (updatedOrder.order_notes || '');
          saveNotesBtn.disabled = !hasChanges;
          
          if (hasChanges) {
            saveNotesBtn.textContent = "Save Notes";
            saveNotesBtn.style.backgroundColor = "#1f6463";
            saveNotesBtn.style.cursor = "pointer";
          } else {
            saveNotesBtn.textContent = "No Changes";
            saveNotesBtn.style.backgroundColor = "#ccc";
            saveNotesBtn.style.cursor = "not-allowed";
          }
        }

        // Reattach event listeners
        const reattachListeners = (editor, saveBtn) => {
          // Clear existing listeners
          const newEditor = editor.cloneNode(true);
          editor.parentNode.replaceChild(newEditor, editor);

          // Add input event listener
          newEditor.addEventListener('input', () => {
            const currentValue = newEditor.value;
            const previousValue = newEditor.dataset.previousValue || '';
            const hasChanges = currentValue !== previousValue;
            
            if (saveBtn) {
              saveBtn.disabled = !hasChanges;
              if (hasChanges) {
                saveBtn.textContent = "Save Notes";
                saveBtn.style.backgroundColor = "#1f6463";
                saveBtn.style.cursor = "pointer";
              } else {
                saveBtn.textContent = "No Changes";
                saveBtn.style.backgroundColor = "#ccc";
                saveBtn.style.cursor = "not-allowed";
              }
            }
          });

          // Handle paste and cut events
          ['paste', 'cut'].forEach(eventName => {
            newEditor.addEventListener(eventName, () => {
              setTimeout(() => newEditor.dispatchEvent(new Event('input')), 0);
            });
          });

          // Add Ctrl+Enter / Cmd+Enter save shortcut
          newEditor.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter' && !saveNotesBtn.disabled) {
              e.preventDefault();
              saveNotesBtn.click();
            }
          });

          // Update save button click handler
          if (saveBtn) {
            const newSaveBtn = saveBtn.cloneNode(true);
            saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
            
            newSaveBtn.addEventListener('click', () => {
              if (newEditor.value !== newEditor.dataset.previousValue) {
                saveStaffNotes(updatedOrder.id, newEditor.value, newEditor, newSaveBtn);
              }
            });
          }

          return newEditor;
        };

        // Reattach all listeners
        staffNotesEditor = reattachListeners(staffNotesEditor, saveNotesBtn);
      }

      // Store the current state of the staff notes and details section
      const detailsSection = orderCard.querySelector('.details-section');
      const isExpanded = detailsSection?.classList.contains('visible');
      const currentNotesValue = staffNotesEditor ? staffNotesEditor.value : '';
      const isEditorFocused = staffNotesEditor === document.activeElement;
      const cursorPosition = staffNotesEditor ? staffNotesEditor.selectionStart : 0;

      // If the card was expanded, we need to re-expand it and restore the staff notes
      if (isExpanded) {
        const newDetailsSection = orderCard.querySelector('.details-section');
        const newToggleBtn = orderCard.querySelector('.details-toggle');
        const newStaffNotesEditor = orderCard.querySelector('.staff-notes-editor');
        const newSaveNotesBtn = orderCard.querySelector('.save-notes-btn');

        if (newDetailsSection) {
          newDetailsSection.classList.add('visible');
        }
        
        if (newToggleBtn) {
          newToggleBtn.textContent = "Hide ▲";
        }

        // Always reinitialize the staff notes editor with fresh data
        if (newStaffNotesEditor) {
          // If the editor was being edited, preserve the current state
          if (isEditorFocused) {
            newStaffNotesEditor.value = currentNotesValue;
            newStaffNotesEditor.dataset.previousValue = updatedOrder.order_notes || '';
            setTimeout(() => {
              newStaffNotesEditor.focus();
              newStaffNotesEditor.setSelectionRange(cursorPosition, cursorPosition);
            }, 0);
          } else {
            // Otherwise use the latest data from the server
            newStaffNotesEditor.value = updatedOrder.order_notes || '';
            newStaffNotesEditor.dataset.previousValue = updatedOrder.order_notes || '';
          }

          // Ensure the editor is enabled
          newStaffNotesEditor.disabled = false;
          newStaffNotesEditor.readOnly = false;

          // Update save button state
          if (newSaveNotesBtn) {
            const hasChanges = newStaffNotesEditor.value !== newStaffNotesEditor.dataset.previousValue;
            newSaveNotesBtn.disabled = !hasChanges;
            newSaveNotesBtn.textContent = hasChanges ? "Save Notes" : "No Changes";
            newSaveNotesBtn.style.backgroundColor = hasChanges ? "#1f6463" : "#ccc";
            newSaveNotesBtn.style.cursor = hasChanges ? "pointer" : "not-allowed";
          }

          // Reattach all event listeners
          const reattachEditorListeners = () => {
            // Clear existing listeners
            const freshEditor = newStaffNotesEditor.cloneNode(true);
            newStaffNotesEditor.parentNode.replaceChild(freshEditor, newStaffNotesEditor);

            // Add input event listener
            freshEditor.addEventListener('input', () => {
              const hasChanges = freshEditor.value !== freshEditor.dataset.previousValue;
              if (newSaveNotesBtn) {
                newSaveNotesBtn.disabled = !hasChanges;
                newSaveNotesBtn.textContent = hasChanges ? "Save Notes" : "No Changes";
                newSaveNotesBtn.style.backgroundColor = hasChanges ? "#1f6463" : "#ccc";
                newSaveNotesBtn.style.cursor = hasChanges ? "pointer" : "not-allowed";
              }
            });

            // Handle paste and cut events
            ['paste', 'cut'].forEach(eventName => {
              freshEditor.addEventListener(eventName, () => {
                setTimeout(() => freshEditor.dispatchEvent(new Event('input')), 0);
              });
            });

            // Add Ctrl+Enter / Cmd+Enter save shortcut
            freshEditor.addEventListener('keydown', (e) => {
              if ((e.ctrlKey || e.metaKey) && e.key === 'Enter' && !newSaveNotesBtn?.disabled) {
                e.preventDefault();
                newSaveNotesBtn.click();
              }
            });

            return freshEditor;
          };

          // Reattach save button listeners
          const reattachSaveButtonListeners = () => {
            if (!newSaveNotesBtn) return;

            const freshSaveBtn = newSaveNotesBtn.cloneNode(true);
            newSaveNotesBtn.parentNode.replaceChild(freshSaveBtn, newSaveNotesBtn);

            freshSaveBtn.addEventListener('click', () => {
              const editor = orderCard.querySelector('.staff-notes-editor');
              if (editor && editor.value !== editor.dataset.previousValue) {
                saveStaffNotes(updatedOrder.id, editor.value, editor, freshSaveBtn);
              }
            });

            return freshSaveBtn;
          };

          // Apply the reattached listeners
          const freshEditor = reattachEditorListeners();
          const freshSaveBtn = reattachSaveButtonListeners();

          // If we were editing, restore focus
          if (isEditorFocused) {
            setTimeout(() => {
              freshEditor.focus();
              freshEditor.setSelectionRange(cursorPosition, cursorPosition);
            }, 0);
          }
        }
      }
    }

    // Add the delete confirmation overlay to the body
    const deleteOverlay = document.createElement("div");
    deleteOverlay.id = "deleteConfirmationOverlay";
    deleteOverlay.className = "delete-confirmation-overlay";
    deleteOverlay.style.display = "none";
    document.body.appendChild(deleteOverlay);

    // Function to show delete confirmation
    function showDeleteConfirmation(orderId) {
      const overlay = document.getElementById("deleteConfirmationOverlay");
      overlay.innerHTML = `
        <div class="delete-confirmation-box">
          <h3>Delete Order</h3>
          <p>Are you sure you want to delete this order? This action cannot be undone.</p>
          <div class="delete-confirmation-buttons">
            <button class="delete-cancel-btn" onclick="hideDeleteConfirmation()">Cancel</button>
            <button class="delete-confirm-btn" onclick="deleteOrder('${orderId}')">Delete</button>
          </div>
        </div>
      `;
      overlay.style.display = "flex";
    }

    // Function to hide delete confirmation
    function hideDeleteConfirmation() {
      const overlay = document.getElementById("deleteConfirmationOverlay");
      overlay.style.display = "none";
    }

    // Function to delete order
    async function deleteOrder(orderId) {
      try {
        console.log('🗑️ Attempting to delete order:', orderId);
        
        const response = await fetch(`/dashboard/order/${orderId}`, {
          method: 'DELETE',
          credentials: 'include'
        });

        if (!response.ok) {
          const data = await response.json();
          console.error('❌ Delete response:', {
            status: response.status,
            data: data
          });
          throw new Error(data.error || data.details || 'Failed to delete order');
        }

        // Hide the confirmation overlay
        hideDeleteConfirmation();

        // Remove the order from state
        state.allOrders = state.allOrders.filter(order => {
          // Match either the exact ID or with/without order_ prefix
          const cleanOrderId = order.id.replace(/^order_/, '');
          const cleanInputId = orderId.replace(/^order_/, '');
          return cleanOrderId !== cleanInputId;
        });

        // Find and remove the card with animation
        const card = document.querySelector(`[data-order-id="${orderId}"]`);
        if (card) {
          card.style.transition = "all 0.3s ease";
          card.style.opacity = "0";
          card.style.transform = "scale(0.9)";
          setTimeout(() => card.remove(), 300);
        }

        // Show success notification
        ui.showNotification('Order deleted successfully');

      } catch (err) {
        console.error('Failed to delete order:', err);
        ui.showError(err.message || 'Failed to delete order');
        hideDeleteConfirmation();
      }
    }

    // Make functions available globally
    window.showDeleteConfirmation = showDeleteConfirmation;
    window.hideDeleteConfirmation = hideDeleteConfirmation;
    window.deleteOrder = deleteOrder;

    // Function to handle staff notes save
    async function saveStaffNotes(orderId, notes, editor, saveBtn) {
      try {
        // Store current editor state
        const wasEditorFocused = editor === document.activeElement;
        const cursorPosition = editor.selectionStart;
        
        saveBtn.disabled = true;
        saveBtn.textContent = 'Saving...';
        saveBtn.style.backgroundColor = "#ccc";
        saveBtn.style.cursor = "not-allowed";

        const response = await fetch("/dashboard/update-staff-notes", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          credentials: 'include',
          body: JSON.stringify({
            orderId: orderId,
            staffNotes: notes
          })
        });

        if (!response.ok) {
          throw new Error('Failed to save notes');
        }

        const data = await response.json();
        
        // Show success notification
        ui.showNotification('Staff notes updated successfully');

        // Fetch fresh orders data
        try {
          // Get current filter states
          const showOld = document.getElementById("showOldToggle").checked;
          const showCompleted = document.getElementById("showCompletedToggle").checked;

          // Build query string
          const params = new URLSearchParams({
            showOld: showOld.toString(),
            showCompleted: showCompleted.toString(),
            showClaimed: (state.currentTab === "claimed").toString()
          });

          const ordersResponse = await fetch(`/dashboard/data?${params.toString()}`, {
            credentials: 'include'
          });
          
          if (!ordersResponse.ok) {
            throw new Error('Failed to fetch updated orders');
          }
          
          const orders = await ordersResponse.json();
          
          // Find the updated order
          const updatedOrder = orders.find(o => o.id === orderId);
          if (!updatedOrder) {
            console.warn('Updated order not found in response');
            return;
          }

          // Update order in state
          const orderIndex = state.allOrders.findIndex(o => o.id === orderId);
          if (orderIndex !== -1) {
            state.allOrders[orderIndex] = updatedOrder;
          }
          
          // Find the card in the DOM
          const orderCard = document.querySelector(`[data-order-id="${orderId}"]`);
          if (!orderCard) {
            console.warn('Order card not found in DOM');
            return;
          }
          
          // Create a temporary container
          const tempContainer = document.createElement('div');
          
          // Render a single order into the temporary container
          await renderOrders([updatedOrder], true, tempContainer);
          
          // Get the newly rendered card
          const newCard = tempContainer.firstChild;
          if (!newCard) {
            console.warn('Failed to render new card');
            return;
          }
          
          // Replace the old card with the new one
          if (orderCard.parentNode) {
            orderCard.parentNode.replaceChild(newCard, orderCard);
            
            // Find the new editor and restore focus if needed
            if (wasEditorFocused) {
              const newEditor = newCard.querySelector('.staff-notes-editor');
              if (newEditor) {
                newEditor.focus();
                newEditor.setSelectionRange(cursorPosition, cursorPosition);
              }
            }
            
            console.log('Successfully refreshed order card');
          } else {
            console.warn('Order card parent not found, cannot replace');
          }
        } catch (refreshError) {
          console.error('Failed to refresh card:', refreshError);
          // Even if refresh fails, the save was successful, so don't throw
          // Instead, just update the existing editor with the saved notes
          if (editor && editor.isConnected) {
            editor.value = notes;
            editor.dataset.previousValue = notes;
            editor.disabled = false;
            editor.readOnly = false;
            
            if (saveBtn) {
              saveBtn.textContent = "Save Notes";
              saveBtn.disabled = true;
              saveBtn.style.backgroundColor = "#ccc";
              saveBtn.style.cursor = "not-allowed";
            }
          }
        }

      } catch (err) {
        console.error('Failed to save staff notes:', err);
        ui.showError('Failed to save staff notes');
        
        // Reset button and editor state on error
        saveBtn.textContent = 'Save Notes';
        saveBtn.disabled = false;
        saveBtn.style.backgroundColor = "#1f6463";
        saveBtn.style.cursor = "pointer";
        
        editor.disabled = false;
        editor.readOnly = false;
        editor.style.backgroundColor = "";
        
        // Restore focus if editor was focused
        if (editor === document.activeElement) {
          editor.focus();
        }
      }
    }

    // SSE Connection Management
    class EventSourceManager {
      constructor() {
        this.eventSource = null;
        this.lastSequence = 0;
        this.connectionAttempts = 0;
        this.maxRetries = 5;
        this.retryDelay = 1000;
        this.reconnectTimer = null;
        this.connected = false;
        this.username = null;
        this.isRefreshing = false;
        this.connect();
      }

      connect() {
        if (this.eventSource) {
          this.eventSource.close();
        }

        this.eventSource = new EventSource('/dashboard/updates');
        
        this.eventSource.addEventListener('connect', (e) => {
          console.log('✅ Connected to SSE');
          this.connected = true;
          this.connectionAttempts = 0;
          const data = JSON.parse(e.data);
          this.connectionId = data.id;
          this.username = data.username;
          
          // Only refresh on initial connection, not reconnections
          if (!this.lastSequence) {
            this.refreshData();
          }
        });

        this.eventSource.addEventListener('heartbeat', (e) => {
          this.lastHeartbeat = Date.now();
          // Touch the session to keep it alive
          fetch('/dashboard/whoami', { credentials: 'include' }).catch(() => {});
        });

        this.eventSource.addEventListener('orderUpdate', (e) => {
          if (!this.connected || this.isRefreshing) return;
          
          try {
            const update = JSON.parse(e.data);
            
            // Check sequence number
            if (update.sequence && this.lastSequence && update.sequence !== this.lastSequence + 1) {
              console.warn(`Sequence gap detected: expected ${this.lastSequence + 1}, got ${update.sequence}`);
              this.refreshData();
              return;
            }
            
            this.lastSequence = update.sequence || this.lastSequence;
            
            // Handle the update based on type
            switch (update.type) {
              case 'staff':
                handleStaffUpdate(update);
                break;
              case 'delete':
                this.handleOrderDeletion(update);
                break;
              case 'new':
                // For new orders, add them to state and re-filter
                if (!state.allOrders.find(o => o.id === update.order.id)) {
                  state.allOrders.unshift(update.order);
                  const query = document.getElementById("searchInput")?.value || '';
                  filterOrders(query);
                }
                break;
              default:
                this.handleOrderUpdate(update);
            }
          } catch (err) {
            console.error('Error processing order update:', err);
            // Don't refresh on processing errors to avoid cascading issues
          }
        });

        this.eventSource.onerror = (error) => {
          console.error('SSE Connection Error:', error);
          this.connected = false;
          this.eventSource.close();
          
          if (this.connectionAttempts < this.maxRetries) {
            this.connectionAttempts++;
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = setTimeout(() => this.connect(), this.retryDelay * this.connectionAttempts);
          } else {
            console.error('Max reconnection attempts reached');
            this.showReconnectionError();
          }
        };
      }

      async refreshData() {
        if (this.isRefreshing) return;
        
        this.isRefreshing = true;
        try {
          const showOld = document.getElementById("showOldToggle")?.checked || false;
          const showCompleted = document.getElementById("showCompletedToggle")?.checked || false;
          
          const params = new URLSearchParams({
            showOld: showOld.toString(),
            showCompleted: showCompleted.toString(),
            showClaimed: (state.currentTab === "claimed").toString()
          });

          const response = await fetch(`/dashboard/data?${params.toString()}`, {
            credentials: 'include'
          });
          
          if (!response.ok) throw new Error('Failed to fetch orders');
          const orders = await response.json();
          updateAllOrders(orders);
        } catch (error) {
          console.error('Error fetching orders:', error);
        } finally {
          this.isRefreshing = false;
        }
      }

      handleOrderUpdate(update) {
        const { order } = update;
        const orderElement = document.querySelector(`[data-order-id="${order.id}"]`);
        
        if (orderElement) {
          try {
            // Update the order in state
            const orderIndex = state.allOrders.findIndex(o => o.id === order.id);
            if (orderIndex !== -1) {
              state.allOrders[orderIndex] = order;
            }
            
            // Update the UI
            updateOrderUI(orderElement, order, update.metadata);
          } catch (err) {
            console.error(`Failed to update order ${order.id}:`, err);
          }
        } else {
          // If order doesn't exist in UI but should, add it
          if (!state.allOrders.find(o => o.id === order.id)) {
            state.allOrders.unshift(order);
          }
          const query = document.getElementById("searchInput")?.value || '';
          filterOrders(query);
        }
      }

      handleOrderDeletion(update) {
        // Remove from state
        state.allOrders = state.allOrders.filter(order => order.id !== update.orderId);
        
        // Remove from UI
        const orderElement = document.querySelector(`[data-order-id="${update.orderId}"]`);
        if (orderElement) {
          orderElement.remove();
        }
      }

      showReconnectionError() {
        const existingBanner = document.querySelector('.error-banner');
        if (existingBanner) return;

        const errorBanner = document.createElement('div');
        errorBanner.className = 'error-banner';
        errorBanner.innerHTML = `
          <p>Lost connection to server. Please refresh the page.</p>
          <button onclick="window.location.reload()">Refresh Now</button>
        `;
        document.body.prepend(errorBanner);
      }
    }

    // Initialize SSE manager
    const eventManager = new EventSourceManager();

    // Periodic health check
    setInterval(() => {
      if (eventManager.lastHeartbeat && Date.now() - eventManager.lastHeartbeat > 20000) {
        console.warn('No heartbeat received, reconnecting...');
        eventManager.connect();
      }
    }, 10000);

    // Update order UI
    function updateOrderUI(orderElement, order, metadata = {}) {
      // Update assigned staff
      const staffDisplay = orderElement.querySelector('.assigned-staff');
      if (staffDisplay) {
        const staffList = order.assigned_staff ? order.assigned_staff.split(',') : [];
        staffDisplay.textContent = staffList.join(', ') || 'Unassigned';
        staffDisplay.title = `Last updated: ${formatDate(order.last_updated)}`;
      }

      // Update submission date/time
      const submissionTime = orderElement.querySelector('.submission-time');
      if (submissionTime) {
        const submittedAt = order.submitted_at ? new Date(order.submitted_at) : null;
        submissionTime.textContent = submittedAt ? formatDate(submittedAt) : 'Unknown';
        submissionTime.title = `Submitted: ${submittedAt ? submittedAt.toLocaleString() : 'Unknown'}`;
      }

      // Update other order details
      updateOrderStatus(orderElement, order);
      updateOrderClaim(orderElement, order);
      updateOrderPrice(orderElement, order);
      updateOrderNotes(orderElement, order);

      // Add visual feedback for updates
      addUpdateFeedback(orderElement);
    }

    // Add the missing update functions
    function updateOrderStatus(orderElement, order) {
      const statusDropdown = orderElement.querySelector('.status-dropdown');
      if (statusDropdown) {
        const newStatus = order.status || 'pending';
        statusDropdown.value = newStatus;
        statusDropdown.dataset.previousValue = newStatus;
        applyStatusColor(statusDropdown, newStatus);
      }
    }

    function updateOrderClaim(orderElement, order) {
      const actionBtn = orderElement.querySelector('.action-button:not(.save-notes-btn):not(.save-price-btn)');
      if (actionBtn) {
        if (order.status?.toLowerCase() === 'completed') {
          // Replace with completed label
          const completedLabel = document.createElement("button");
          completedLabel.textContent = "Completed";
          completedLabel.disabled = true;
          completedLabel.className = "action-button";
          completedLabel.style.backgroundColor = "#999";
          completedLabel.style.color = "#666";
          completedLabel.style.cursor = "not-allowed";
          actionBtn.replaceWith(completedLabel);
        } else if (order.claimed_by === state.currentUser) {
          // Replace with unclaim button if not already an unclaim button
          if (!actionBtn.textContent.includes('Unclaim')) {
            actionBtn.replaceWith(createUnclaimButton(order));
          }
        } else {
          // Update or replace with claim button
          const newClaimBtn = document.createElement('button');
          newClaimBtn.className = 'action-button';
          
          if (order.claimed_by) {
            newClaimBtn.textContent = `Claimed by ${order.claimed_by}`;
            newClaimBtn.disabled = true;
            newClaimBtn.style.backgroundColor = '#999';
            newClaimBtn.style.cursor = 'not-allowed';
          } else {
            newClaimBtn.textContent = 'Claim Order';
            newClaimBtn.addEventListener('click', async () => {
              try {
                newClaimBtn.textContent = 'Claiming...';
                newClaimBtn.disabled = true;
                newClaimBtn.classList.add('claiming');

                const response = await api.claimOrder(order.id);
                
                if (response && response.order) {
                  Object.assign(order, response.order);
                  updateStaffTagsForOrder(orderElement, [state.currentUser]);
                  newClaimBtn.replaceWith(createUnclaimButton(order));
                }
              } catch (err) {
                console.error(`Failed to claim order ${order.id}:`, err);
                ui.showError(err.message || "Failed to claim order");
                newClaimBtn.textContent = 'Claim Order';
                newClaimBtn.disabled = false;
                newClaimBtn.classList.remove('claiming');
              }
            });
          }
          
          actionBtn.replaceWith(newClaimBtn);
        }
      }
    }

    function updateOrderPrice(orderElement, order) {
      // Update estimated price
      const priceElement = orderElement.querySelector('p');
      if (priceElement && priceElement.innerHTML.includes('Est. Price:')) {
        priceElement.innerHTML = `<strong>Est. Price:</strong> ${order.est_price ? `$${order.est_price.toFixed(2)}` : '—'}`;
      }

      // Update assigned price input if it exists and details are visible
      const assignedPriceInput = orderElement.querySelector('.assigned-price-input');
      if (assignedPriceInput) {
        const currentValue = assignedPriceInput.value;
        const newValue = order.assigned_price || '';
        
        // Only update if the user isn't currently editing
        if (assignedPriceInput !== document.activeElement) {
          assignedPriceInput.value = newValue;
          assignedPriceInput.dataset.previousValue = newValue;
          
          // Update save button state
          const savePriceBtn = orderElement.querySelector('.save-price-btn');
          if (savePriceBtn) {
            savePriceBtn.disabled = true;
            savePriceBtn.style.backgroundColor = "#ccc";
            savePriceBtn.style.cursor = "not-allowed";
          }
        }
      }
    }

    function updateOrderNotes(orderElement, order) {
      // Update staff notes if they exist and details are visible
      const staffNotesEditor = orderElement.querySelector('.staff-notes-editor');
      if (staffNotesEditor) {
        // Only update if the editor is not currently focused (being edited)
        const isEditorFocused = staffNotesEditor === document.activeElement;
        
        if (!isEditorFocused) {
          staffNotesEditor.value = order.order_notes || '';
          staffNotesEditor.dataset.previousValue = order.order_notes || '';
        }

        // Update save button state
        const saveNotesBtn = orderElement.querySelector('.save-notes-btn');
        if (saveNotesBtn) {
          const currentValue = staffNotesEditor.value;
          const hasChanges = currentValue !== (order.order_notes || '');
          
          saveNotesBtn.disabled = !hasChanges;
          saveNotesBtn.textContent = hasChanges ? "Save Notes" : "No Changes";
          saveNotesBtn.style.backgroundColor = hasChanges ? "#1f6463" : "#ccc";
          saveNotesBtn.style.cursor = hasChanges ? "pointer" : "not-allowed";
        }
      }
    }

    // Format date for display
    function formatDate(dateString) {
      if (!dateString) return 'Unknown';
      const date = new Date(dateString);
      if (isNaN(date.getTime())) return 'Invalid Date';

      const now = new Date();
      const diff = now - date;
      const seconds = Math.floor(diff / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);

      // For recent times, show relative time
      if (seconds < 60) return 'just now';
      if (minutes < 60) return `${minutes}m ago`;
      if (hours < 24) return `${hours}h ago`;
      if (days < 7) return `${days}d ago`;

      // For older times, show actual date
      return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }

    // Add visual feedback for updates
    function addUpdateFeedback(element) {
      element.classList.add('updated');
      setTimeout(() => element.classList.remove('updated'), 1000);
    }

    // Add styles for update animation
    const updateStyles = document.createElement('style');
    updateStyles.textContent = `
      .order-card {
        transition: background-color 0.3s ease;
      }
      .updated {
        background-color: rgba(255, 255, 0, 0.1) !important;
      }
      .submission-time {
        color: #666;
        font-size: 0.9em;
        margin-top: 4px;
      }
      .assigned-staff {
        font-weight: bold;
        color: #2196F3;
      }
    `;
    document.head.appendChild(updateStyles);

    // Add or update submission time to order cards
    function addSubmissionTimeToOrders() {
      const orders = document.querySelectorAll('.order-card');
      orders.forEach(order => {
        let submissionTime = order.querySelector('.submission-time');
        if (!submissionTime) {
          submissionTime = document.createElement('div');
          submissionTime.className = 'submission-time';
          order.querySelector('.order-header').appendChild(submissionTime);
        }
        const submittedAt = order.dataset.submittedAt;
        submissionTime.textContent = formatDate(submittedAt);
        submissionTime.title = `Submitted: ${new Date(submittedAt).toLocaleString()}`;
      });
    }

    // Call this when page loads and after any updates
    document.addEventListener('DOMContentLoaded', addSubmissionTimeToOrders);

    // Handle order deletion
    function handleOrderDeletion(update) {
      const orderElement = document.querySelector(`[data-order-id="${update.orderId}"]`);
      if (orderElement) { 
        orderElement.remove();
      }
    }

    // Show reconnection error
    function showReconnectionError() {
      const errorBanner = document.createElement('div');
      errorBanner.className = 'error-banner';
      errorBanner.innerHTML = `
        <p>Lost connection to server. Please refresh the page.</p>
        <button onclick="window.location.reload()">Refresh Now</button>
      `;
      document.body.prepend(errorBanner);
    }

    // Fetch and update all orders
    async function fetchAndUpdateOrders() {
      try {
        const response = await fetch('/dashboard/data' + window.location.search);
        if (!response.ok) throw new Error('Failed to fetch orders');
        const orders = await response.json();
        updateAllOrders(orders);
      } catch (error) {
        console.error('Error fetching orders:', error);
      }
    }

    // Update all orders in the UI
    function updateAllOrders(orders) {
      const orderGrid = document.querySelector('#orderGrid');
      if (!orderGrid) {
        console.error('Order grid element not found');
        return;
      }

      // Store current scroll position
      const scrollPosition = window.scrollY;

      // Store expanded states before clearing
      const expandedStates = new Map();
      const existingCards = orderGrid.querySelectorAll('.card[data-order-id]');
      existingCards.forEach(card => {
        const orderId = card.dataset.orderId;
        const detailsSection = card.querySelector('.details-section');
        const isExpanded = detailsSection?.classList.contains('visible');
        
        // Store staff notes state if expanded
        let staffNotesState = null;
        if (isExpanded) {
          const staffNotesEditor = card.querySelector('.staff-notes-editor');
          if (staffNotesEditor) {
            staffNotesState = {
              value: staffNotesEditor.value,
              isEditing: staffNotesEditor === document.activeElement,
              cursorPosition: staffNotesEditor.selectionStart,
              previousValue: staffNotesEditor.dataset.previousValue
            };
          }
        }
        
        expandedStates.set(orderId, {
          isExpanded,
          staffNotesState
        });
      });

      // Update state
      state.allOrders = orders;
      
      // Clear and re-render based on current tab
      orderGrid.innerHTML = '';
      
      if (state.currentTab === "claimed") {
        renderClaimedOrders(orders, false);
      } else {
        renderOrders(orders, false);
      }

      // Restore expanded states
      setTimeout(() => {
        expandedStates.forEach((state, orderId) => {
          const card = document.querySelector(`[data-order-id="${orderId}"]`);
          if (card && state.isExpanded) {
            const detailsSection = card.querySelector('.details-section');
            const toggleBtn = card.querySelector('.details-toggle');
            
            if (detailsSection) {
              detailsSection.classList.add('visible');
            }
            if (toggleBtn) {
              toggleBtn.textContent = "Hide ▲";
            }

            // Restore staff notes state if it existed
            if (state.staffNotesState) {
              const staffNotesEditor = card.querySelector('.staff-notes-editor');
              if (staffNotesEditor) {
                if (state.staffNotesState.isEditing) {
                  staffNotesEditor.value = state.staffNotesState.value;
                  staffNotesEditor.dataset.previousValue = state.staffNotesState.previousValue;
                  
                  setTimeout(() => {
                    staffNotesEditor.focus();
                    staffNotesEditor.setSelectionRange(
                      state.staffNotesState.cursorPosition, 
                      state.staffNotesState.cursorPosition
                    );
                  }, 50);

                  // Update save button state
                  const saveBtn = card.querySelector('.save-notes-btn');
                  if (saveBtn) {
                    const hasChanges = staffNotesEditor.value !== staffNotesEditor.dataset.previousValue;
                    saveBtn.disabled = !hasChanges;
                    saveBtn.textContent = hasChanges ? "Save Notes" : "No Changes";
                    saveBtn.style.backgroundColor = hasChanges ? "#1f6463" : "#ccc";
                    saveBtn.style.cursor = hasChanges ? "pointer" : "not-allowed";
                  }
                }
              }
            }
          }
        });
      }, 100);

      // Restore scroll position
      window.scrollTo(0, scrollPosition);
    }

    // Add styles for error banner
    const styles = document.createElement('style');
    styles.textContent = `
      .error-banner {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: #ff5252;
        color: white;
        padding: 1rem;
        text-align: center;
        z-index: 9999;
      }
      .error-banner button {
        margin-left: 1rem;
        padding: 0.5rem 1rem;
        background: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
      }
    `;
    document.head.appendChild(styles);

    // Simplified and more reliable staff update handling
    function handleStaffUpdate(update) {
      const { order, metadata } = update;
      const currentUser = state.currentUser;
      
      console.log('🔄 Handling staff update:', {
        orderId: order.id,
        assignedStaff: order.assigned_staff,
        currentUser: currentUser,
        currentTab: state.currentTab
      });

      // Update the order in state
      const orderIndex = state.allOrders.findIndex(o => o.id === order.id);
      if (orderIndex !== -1) {
        state.allOrders[orderIndex] = order;
      }

      // Find the existing card
      const orderCard = document.querySelector(`[data-order-id="${order.id}"]`);
      
      if (orderCard) {
        // Simply update the staff tags - no complex logic
        updateStaffTagsForOrder(orderCard, order.assigned_staff ? order.assigned_staff.split(',').map(s => s.trim()) : []);
        
        // Update other card elements
        updateCardElements(orderCard, order);
        
        // Add visual feedback
        addUpdateFeedback(orderCard);
      }

      // For claimed tab, do a simple filter check instead of complex refresh logic
      if (state.currentTab === "claimed") {
        const currentStaffList = order.assigned_staff ? order.assigned_staff.split(',').map(s => s.trim()) : [];
        const isUserAssigned = currentStaffList.includes(currentUser) || order.claimed_by === currentUser;
        const isCompleted = order.status?.toLowerCase() === "completed";
        
        if (orderCard && (!isUserAssigned || isCompleted)) {
          // Remove card if user is no longer assigned
          orderCard.style.transition = "all 0.3s ease";
          orderCard.style.opacity = "0";
          orderCard.style.transform = "scale(0.9)";
          setTimeout(() => {
            if (orderCard.isConnected) {
              orderCard.remove();
            }
          }, 300);
        } else if (!orderCard && isUserAssigned && !isCompleted) {
          // Add card if user was just assigned - use simple approach
          const query = document.getElementById("searchInput")?.value || '';
          filterOrders(query);
        }
      }
    }
  </script>

  <div id="loginOverlay" class="login-overlay">
    <div class="login-box">
      <h2>FilamentBros Login</h2>
      <form id="loginForm">
        <input type="text" id="username" placeholder="Username" required />
        <input type="password" id="password" placeholder="Password" required />
        <label class="remember-line">
          <input type="checkbox" id="rememberMe" />
          Remember Me
        </label>
        <button type="submit">Login</button>
        <p id="loginError" style="color: red; display: none; font-size: 0.85rem"></p>
      </form>
    </div>
  </div>
</body>

</html>     