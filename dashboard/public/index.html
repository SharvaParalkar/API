<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>FilamentBros Order Dashboard</title>
  <style>
    body {
      font-family: "Roboto", sans-serif;
      margin: 0;
      padding: 2rem;
      background-color: #f5f5f5;
    }

    h1 {
      text-align: center;
      color: #1f6463;
      margin-bottom: 1rem;
    }

    .search-container {
      max-width: 700px;
      margin-left: auto;
      margin-right: auto;
      margin-bottom: 2rem;
      display: flex;
      gap: 1rem;
      align-items: center;
      justify-content: center;
      width: 100%;
      padding: 0 1rem;
    }

    .search-container input {
      width: 100%;
      max-width: 700px;
      flex: 1;
      padding: 0.75rem;
      font-size: 1rem;
      border: 2px solid #ccc;
      border-radius: 5rem;
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 1.5rem;
      align-items: start;
    }

    .card {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      background: white;
      border-radius: 1rem;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      padding: 1.25rem;
      color: #333;
      position: relative;
      height: auto;
    }

    .card h2 {
      font-size: 1.2rem;
      margin-bottom: 1rem;
      color: #1f6463;
      margin: 0 0 0.75rem 0;
    }

    .card ul {
      padding-left: 1rem;
      margin: 0;
      font-size: 0.95rem;
      list-style: disc;
    }

    .card:hover {
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.15);
      transform: translateY(-3px);
      transition: 0.2s ease;
    }

    .card ul li {
      margin-bottom: 0.5rem;
    }

    .order-id {
      margin-top: 1.25rem;
      padding-top: 0.75rem;
      border-top: 1px solid #ddd;
      text-align: center;
      font-size: 0.8rem;
      color: #666;
      font-weight: bold;
    }

    .stl-header {
      font-weight: bold;
      margin-top: 1rem;
      margin-bottom: 0.5rem;
    }

    .stl-list {
      padding-left: 1.2rem;
      list-style-type: disc;
      margin-top: 0;
      margin-bottom: 0.75rem;
    }

    .stl-list li {
      font-size: 0.9rem;
      margin-bottom: 0.35rem;
    }

    .stl-link {
      display: block;
      max-width: 100%;
      color: #1f6463;
      text-decoration: none;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: normal;
      word-break: break-word;
      /* Ensures long words break cleanly */
    }

    .download-all-btn {
      margin-top: 0.25rem;
      display: inline-block;
      margin-top: 0.5rem;
      padding: 0.4rem 0.75rem;
      background-color: #1f6463;
      color: white;
      text-decoration: none;
      border-radius: 6px;
      font-size: 0.85rem;
    }

    .status-submitted {
      background-color: #1f6463;
    }

    .status-complete {
      background-color: #5cb85c;
    }

    .status-failed {
      background-color: #d9534f;
    }

    .details-toggle {
      margin-top: 0.5rem;
      font-size: 0.85rem;
      color: #1f6463;
      background: none;
      border: none;
      font-weight: bold;
      cursor: pointer;
    }

    .details-section {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.6s ease, opacity 0.6s ease;
      opacity: 0;
      margin-top: 0;
    }

    .details-section.visible {
      max-height: 1000px;
      /* large enough to cover any content height */
      opacity: 1;
      margin-top: 0.75rem;
    }

    .details-table {
      width: 100%;
      font-size: 0.9rem;
      border-spacing: 0.4rem 0.25rem;
    }

    .details-table td {
      vertical-align: top;
      padding: 0.2rem 0.5rem;
    }

    .details-table td:first-child {
      font-weight: bold;
      width: 30%;
    }

    .status-dropdown {
      padding: 0.4rem 0.75rem;
      border-radius: 0.5rem;
      border: 1px solid #ccc;
      font-size: 0.9rem;
      background-color: #f5f5f5;
    }

    .status-pending {
      background-color: #ff6e5f;
      color: #000;
    }

    .status-pre-print {
      background-color: #ffaea5;
      color: #000;
    }

    .status-printing {
      background-color: #f4d03f;
      color: #000;
    }

    .status-printing-pay-later {
      background-color: #f4d03f;
      color: #000;
    }

    .status-completed {
      background-color: #2ecc71;
      color: #000;
    }

    .toggle-wrapper {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
      flex-shrink: 0;
    }

    .toggle-wrapper input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: 0.3s;
      border-radius: 24px;
    }

    .slider::before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }

    .toggle-wrapper input:checked+.slider {
      background-color: #1f6463;
    }

    .toggle-wrapper input:checked+.slider::before {
      transform: translateX(20px);
    }

    .toggle-label {
      font-size: 0.9rem;
      margin-left: 0.5rem;
      line-height: 24px;
      color: #333;
    }

    .top-bar {
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 2rem;
      flex-direction: column;
    }

    .toggle-group {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .login-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: white;
      z-index: 9999;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .login-box {
      background: white;
      padding: 2rem;
      border-radius: 1rem;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
      width: 100%;
      max-width: 360px;
      text-align: center;

      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .login-box input[type="text"],
    .login-box input[type="password"] {
      width: 100%;
      padding: 0.75rem;
      margin-bottom: 1rem;
      font-size: 1rem;
      border: 1px solid #ccc;
      border-radius: 0.5rem;
      box-sizing: border-box;
      /* ✅ prevents padding from adding to width */
    }

    .login-box button {
      width: 100%;
      padding: 0.75rem;
      font-size: 1rem;
      background-color: #1f6463;
      color: white;
      border: none;
      border-radius: 0.5rem;
      cursor: pointer;
    }

    .login-box .remember-line {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      font-size: 0.9rem;
      margin-bottom: 1rem;
      justify-content: left;
    }

    .toggles-wrapper {
      display: flex;
      gap: 1rem;
    }

    .search-input-wrapper {
      flex-grow: 1;
      max-width: 700px;
      margin: 0 auto;
    }

    .search-bar-wrapper {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 2rem;
      height: 3.5rem;
    }

    .toggles-wrapper {
      position: absolute;
      left: 0;
      display: flex;
      gap: 1rem;
      align-items: center;
      padding-left: 1rem;
    }

    .centered-search {
      max-width: 700px;
      width: 100%;
      padding: 0.75rem;
      font-size: 1rem;
      border: 2px solid #ccc;
      border-radius: 5rem;
    }

    .search-bar-flex {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
      margin-bottom: 2rem;
      width: 100%;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
      padding: 0 1rem;
    }

    .left-toggles {
      display: flex;
      gap: 1rem;
      align-items: center;
      flex-shrink: 0;
    }

    .center-search {
      flex-grow: 1;
      max-width: 700px;
      display: flex;
      justify-content: center;
    }

    .center-search input {
      width: 100%;
      max-width: 700px;
      padding: 0.75rem;
      font-size: 1rem;
      border: 2px solid #ccc;
      border-radius: 5rem;
      outline: none;
    }

    .center-search input:focus {
      border-color: #1f6463;
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }

      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }

      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }

    .status-history {
      margin-top: 1rem;
      font-size: 0.9rem;
    }

    .status-history-item {
      display: flex;
      justify-content: space-between;
      padding: 0.5rem;
      border-bottom: 1px solid #eee;
    }

    .status-history-item:last-child {
      border-bottom: none;
    }

    .staff-notes-editor {
      width: 100%;
      min-height: 80px;
      padding: 0.5rem;
      border: 1px solid #ccc;
      border-radius: 0.3rem;
      margin-top: 0.3rem;
      font-family: inherit;
      font-size: 0.9rem;
      resize: vertical;
    }

    .save-notes-btn {
      margin-top: 0.5rem;
      padding: 0.4rem 0.8rem;
      background-color: #1f6463;
      color: white;
      border: none;
      border-radius: 0.3rem;
      cursor: pointer;
      font-size: 0.9rem;
    }

    .save-notes-btn:hover {
      background-color: #184f4e;
    }

    .save-notes-btn:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    .dark-mode {
      background-color: #1a1a1a;
      color: #fff;
    }

    .dark-mode .card {
      background-color: #2d2d2d;
      color: #fff;
    }

    .dark-mode .status-dropdown {
      background-color: #3d3d3d;
      color: #fff;
      border-color: #4d4d4d;
    }

    .dark-mode .staff-notes-editor {
      background-color: #3d3d3d;
      color: #fff;
      border-color: #4d4d4d;
    }

    .dark-mode-toggle {
      position: fixed;
      top: 1rem;
      right: 1rem;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
      background-color: #1f6463;
      color: white;
      border: none;
      cursor: pointer;
    }

    .priority-badge {
      display: inline-block;
      padding: 0.2rem 0.5rem;
      border-radius: 0.3rem;
      font-size: 0.8rem;
      margin-left: 0.5rem;
    }

    .priority-high {
      background-color: #ff4444;
      color: white;
    }

    .priority-medium {
      background-color: #ffbb33;
      color: black;
    }

    .priority-low {
      background-color: #00C851;
      color: white;
    }

    .tab-container {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin-bottom: 1rem;
      position: relative;
      z-index: 100;
    }

    .tab-button {
      padding: 0.6rem 1rem;
      border-radius: 1rem;
      border: none;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      transition: all 0.2s ease;
      user-select: none;
      pointer-events: auto;
    }

    .tab-button:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .tab-button:active {
      transform: translateY(0);
    }
  </style>
</head>

<body>
  <h1>FilamentBros Order Dashboard</h1>

  <div class="tab-container">
    <button id="tabAll" class="tab-button"
      style="background: #1f6463; color: white;">All Orders</button>
    <button id="tabClaimed" class="tab-button"
      style="background: #ccc; color: black;">Claimed Orders</button>
  </div>

  <div class="search-bar-flex">
    <div class="left-toggles">
      <div class="toggle-group">
        <span class="toggle-label">Old Orders</span>
        <label class="toggle-wrapper">
          <input type="checkbox" id="showOldToggle" />
          <span class="slider"></span>
        </label>
      </div>

      <div class="toggle-group">
        <span class="toggle-label">Completed</span>
        <label class="toggle-wrapper">
          <input type="checkbox" id="showCompletedToggle" />
          <span class="slider"></span>
        </label>
      </div>

      <div class="toggle-group">
        <select id="staffFilter" style="padding: 0.4rem; border-radius: 0.3rem; border: 1px solid #ccc;">
          <option value="">All Staff</option>
        </select>
      </div>
    </div>

    <div class="center-search">
      <input type="text" id="searchInput" placeholder="Search by name, email, phone, or order ID..." />
    </div>
  </div>

  <div class="grid" id="orderGrid"></div>

  <script>
    // Constants
    const REFRESH_INTERVAL = 10000; // 10 seconds
    const SEARCH_DEBOUNCE = 200; // 200ms
    const MAX_RETRY_ATTEMPTS = 3;
    const VALID_STATUSES = [
      "pending",
      "pre print",
      "printing",
      "printing pay later",
      "completed",
    ];

    // State management
    const state = {
      allOrders: [],
      currentUser: null,
      currentTab: "all",
      retryCount: 0,
      filters: {
        showOld: false,
        showCompleted: false,
        staffFilter: ""
      },
      intervals: [],
      staffMembers: [],
      lastOrderHash: null,
      lastRefreshTime: 0,
      minRefreshInterval: 5000
    };

    // First full load
    async function loadInitialOrders() {
      try {
        const data = await api.fetchOrders();
        state.allOrders = Array.isArray(data) ? data : [];
        console.log('📦 Initial orders loaded:', state.allOrders.length);

        // Initialize search immediately after orders load
        initializeSearch();

        // Apply any existing search query
        const query = document.getElementById("searchInput").value;
        filterOrders(query);
      } catch (err) {
        state.allOrders = [];
        document.getElementById("orderGrid").innerHTML = "<p>⚠️ Failed to load orders.</p>";
        console.error("❌ Failed to load initial orders:", err);
      }
    }

    // Handle incoming order updates
    function handleOrderUpdate(updatedOrder) {
      console.log('🔄 Processing order update:', updatedOrder);

      // Update order in state
      const index = state.allOrders.findIndex(order => order.id === updatedOrder.id);
      if (index !== -1) {
        state.allOrders[index] = updatedOrder;
      } else {
        state.allOrders.unshift(updatedOrder);
      }

      // Get the existing card if it exists
      const orderCard = document.querySelector(`[data-order-id="${updatedOrder.id}"]`);
      
      // Handle claimed tab visibility
      if (state.currentTab === "claimed") {
        const shouldBeVisible = updatedOrder.claimed_by === state.currentUser && 
                              updatedOrder.assigned_staff === state.currentUser &&
                              updatedOrder.status?.toLowerCase() !== "completed";
        
        if (!shouldBeVisible && orderCard) {
          // Smoothly remove the card if it shouldn't be visible
          orderCard.style.transition = "all 0.3s ease";
          orderCard.style.opacity = "0";
          orderCard.style.transform = "scale(0.9)";
          setTimeout(() => orderCard.remove(), 300);
          return;
        }
      }

      if (orderCard) {
        // Update existing card
        const claimBtn = orderCard.querySelector('button:last-child');
        const unclaimBtn = orderCard.querySelector('button[textContent="Unclaim"]');
        
        // Update status dropdown
        const statusDropdown = orderCard.querySelector('.status-dropdown');
        if (statusDropdown) {
          statusDropdown.value = updatedOrder.status || 'pending';
          statusDropdown.dataset.previousValue = updatedOrder.status || 'pending';
          applyStatusColor(statusDropdown, updatedOrder.status || 'pending');
        }

        // Update staff assignment
        const staffSelect = orderCard.querySelector('.staff-dropdown');
        if (staffSelect) {
          staffSelect.value = updatedOrder.assigned_staff || '';
        }

        // Update details section if open
        const detailsSection = orderCard.querySelector('.details-section');
        if (detailsSection?.classList.contains('visible')) {
          // Update staff notes
          const notesCell = [...orderCard.querySelectorAll('td')].find(td => 
            td.textContent.includes('Staff Notes:')
          )?.nextElementSibling;
          if (notesCell) {
            notesCell.textContent = updatedOrder.order_notes || '—';
          }

          // Update last updated by
          const updatedByCell = [...orderCard.querySelectorAll('td')].find(td => 
            td.textContent.includes('Last Updated By:')
          )?.nextElementSibling;
          if (updatedByCell) {
            updatedByCell.textContent = updatedOrder.updated_by || '—';
          }
        }

        // Handle claim/unclaim button updates
        if (updatedOrder.claimed_by === state.currentUser) {
          // If claimed by current user, show unclaim button
          if (claimBtn && !unclaimBtn) {
            const newUnclaimBtn = document.createElement('button');
            newUnclaimBtn.textContent = 'Unclaim';
            newUnclaimBtn.style.cssText = `
              background-color: #ccc;
              border: none;
              color: #333;
              padding: 0.5rem 1rem;
              border-radius: 0.5rem;
              margin-top: 0.5rem;
              cursor: pointer;
            `;

            // Add unclaim functionality
            newUnclaimBtn.addEventListener('click', async () => {
              try {
                newUnclaimBtn.textContent = 'Unclaiming...';
                newUnclaimBtn.disabled = true;
                newUnclaimBtn.style.cursor = 'not-allowed';

                const response = await api.unclaimOrder(updatedOrder.id);
                
                if (state.currentTab === "claimed") {
                  orderCard.style.transition = "all 0.3s ease";
                  orderCard.style.opacity = "0";
                  orderCard.style.transform = "scale(0.9)";
                  setTimeout(() => orderCard.remove(), 300);
                }
              } catch (err) {
                console.error(`Failed to unclaim order ${updatedOrder.id}:`, err);
                ui.showError(err.message || "Failed to unclaim order");
                newUnclaimBtn.textContent = 'Unclaim';
                newUnclaimBtn.disabled = false;
                newUnclaimBtn.style.cursor = 'pointer';
              }
            });

            claimBtn.replaceWith(newUnclaimBtn);
          }
        } else {
          // If not claimed by current user, show appropriate claim button
          if (updatedOrder.claimed_by) {
            if (claimBtn) {
              claimBtn.textContent = `Claimed by ${updatedOrder.claimed_by}`;
              claimBtn.disabled = true;
              claimBtn.style.backgroundColor = '#999';
              claimBtn.style.cursor = 'not-allowed';
            }
          } else {
            if (claimBtn) {
              claimBtn.textContent = 'Claim Order';
              claimBtn.disabled = false;
              claimBtn.style.backgroundColor = '#ccc';
              claimBtn.style.cursor = 'pointer';
            }
          }
        }

        // Update other card elements
        updateCardElements(orderCard, updatedOrder);
      } else {
        // If the card doesn't exist but should be visible, reapply filters
        const query = document.getElementById("searchInput").value;
        filterOrders(query);
      }
    }

    // Helper function to check if an order should be shown based on current filters
    function shouldShowOrder(order) {
      const showOld = document.getElementById("showOldToggle").checked;
      const showCompleted = document.getElementById("showCompletedToggle").checked;

      // Check completed status
      if (!showCompleted && order.status?.toLowerCase() === 'completed') {
        return false;
      }

      // Check age
      if (!showOld) {
        const oneWeekAgo = new Date();
        oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
        const orderDate = new Date(order.submitted_at);
        if (orderDate < oneWeekAgo) {
          return false;
        }
      }

      return true;
    }

    // Helper function to update card elements
    function updateCardElements(card, order) {
      // Update price
      const priceElement = card.querySelector('p');
      if (priceElement) {
        priceElement.innerHTML = `<strong>Est. Price:</strong> ${order.est_price ? `$${order.est_price.toFixed(2)}` : '—'
          }`;
      }

      // Update notes if visible
      const detailsSection = card.querySelector('.details-section');
      if (detailsSection?.classList.contains('visible')) {
        const notesElement = detailsSection.querySelector('td:contains("Staff Notes:")');
        if (notesElement?.nextElementSibling) {
          notesElement.nextElementSibling.textContent = order.order_notes || '—';
        }
      }
    }

    // Utility functions
    const debounce = (func, wait) => {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    };

    const handleError = async (err, operation) => {
      console.error(`❌ Error during ${operation}:`, err);

      if (err.status === 401) {
        clearAllIntervals();
        showLoginOverlay();
        return;
      }

      if (state.retryCount < MAX_RETRY_ATTEMPTS) {
        state.retryCount++;
        await new Promise(resolve => setTimeout(resolve, 1000 * state.retryCount));
        return true; // Retry
      }

      state.retryCount = 0;
      return false; // Don't retry
    };

    const clearAllIntervals = () => {
      state.intervals.forEach(clearInterval);
      state.intervals = [];
    };

    // API functions
    const api = {
      async fetchOrders() {
        try {
          // Get current filter states
          const showOld = document.getElementById("showOldToggle").checked;
          const showCompleted = document.getElementById("showCompletedToggle").checked;

          // Build query string
          const params = new URLSearchParams({
            showOld: showOld.toString(),
            showCompleted: showCompleted.toString(),
            showClaimed: (state.currentTab === "claimed").toString()
          });

          const url = `/dashboard/data?${params.toString()}`;
          console.log('🔍 Fetching orders with filters:', { showOld, showCompleted, showClaimed: state.currentTab === "claimed" });

          const res = await fetch(url, { credentials: 'include' });
          if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);

          const data = await res.json();
          console.log(`📦 Received ${data.length} orders`);
          return data;
        } catch (err) {
          console.error('❌ Failed to fetch orders:', err);
          return [];
        }
      },

      async updateStatus(orderId, status) {
        try {
          const res = await fetch("/dashboard/update-status", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ orderId, status }),
            credentials: 'include'
          });
          if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
          return await res.json();
        } catch (err) {
          await handleError(err, 'updateStatus');
          throw err;
        }
      },

      async assignStaff(orderId, staffName) {
        try {
          const res = await fetch("/dashboard/assign-staff", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ orderId, staffName }),
            credentials: 'include'
          });
          if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
          return await res.json();
        } catch (err) {
          await handleError(err, 'assignStaff');
          throw err;
        }
      },

      async claimOrder(orderId) {
        try {
          const res = await fetch("/dashboard/claim", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ orderId }),
            credentials: 'include'
          });
          if (!res.ok) {
            const data = await res.json();
            throw new Error(data.error || `HTTP error! status: ${res.status}`);
          }
          return await res.json();
        } catch (err) {
          await handleError(err, 'claimOrder');
          throw err;
        }
      },

      async unclaimOrder(orderId) {
        try {
          const res = await fetch("/dashboard/unclaim", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ orderId }),
            credentials: 'include'
          });
          if (!res.ok) {
            const data = await res.json();
            throw new Error(data.error || `HTTP error! status: ${res.status}`);
          }
          return await res.json();
        } catch (err) {
          await handleError(err, 'unclaimOrder');
          throw err;
        }
      },

      async login(username, password, remember) {
        try {
          const formData = new URLSearchParams();
          formData.append("username", username);
          formData.append("password", password);
          if (remember) formData.append("remember", "on");

          const res = await fetch("/dashboard/login", {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: formData.toString(),
            credentials: 'include'
          });

          if (!res.ok) {
            const data = await res.json().catch(() => ({ error: "Login failed" }));
            throw new Error(data.error || "Login failed");
          }

          return true;
        } catch (err) {
          console.error("Login error:", err);
          throw err;
        }
      },

      async checkSession() {
        try {
          const res = await fetch("/dashboard/whoami", { credentials: "include" });
          if (!res.ok) throw new Error("Session check failed");
          return await res.json();
        } catch (err) {
          console.error("Session check error:", err);
          throw err;
        }
      },

      async getStaffList() {
        try {
          const res = await fetch("/dashboard/staff", {
            credentials: 'include'
          });
          if (!res.ok) throw new Error("Failed to fetch staff list");
          return await res.json();
        } catch (err) {
          console.error("Failed to fetch staff list:", err);
          return [];
        }
      }
    };

    // UI update functions
    const ui = {
      updateTabStyles() {
        const allTab = document.getElementById("tabAll");
        const claimedTab = document.getElementById("tabClaimed");

        if (allTab && claimedTab) {
          allTab.style.backgroundColor = state.currentTab === "all" ? "#1f6463" : "#ccc";
          allTab.style.color = state.currentTab === "all" ? "white" : "black";
          claimedTab.style.backgroundColor = state.currentTab === "claimed" ? "#1f6463" : "#ccc";
          claimedTab.style.color = state.currentTab === "claimed" ? "white" : "black";
        }
      },

      showLoginOverlay() {
        const overlay = document.getElementById("loginOverlay");
        if (overlay) overlay.style.display = "flex";
      },

      hideLoginOverlay() {
        const overlay = document.getElementById("loginOverlay");
        if (overlay) overlay.style.display = "none";
      },

      showError(message) {
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background-color: #ff6b6b;
          color: white;
          padding: 1rem;
          border-radius: 0.5rem;
          box-shadow: 0 2px 10px rgba(0,0,0,0.1);
          z-index: 1000;
          animation: slideIn 0.3s ease-out;
        `;
        errorDiv.textContent = message;
        document.body.appendChild(errorDiv);
        setTimeout(() => {
          errorDiv.style.animation = 'slideOut 0.3s ease-in';
          setTimeout(() => errorDiv.remove(), 300);
        }, 3000);
      }
    };

    // Event handlers
    const handlers = {
      async onStatusChange(event, orderId) {
        const newStatus = event.target.value;
        const previousValue = event.target.dataset.previousValue;

        try {
          // Update UI immediately
          applyStatusColor(event.target, newStatus);
          event.target.dataset.previousValue = newStatus;

          console.log(`🔄 Initiating status change for ${orderId}: ${newStatus}`);

          // Send HTTP request
          const response = await api.updateStatus(orderId, newStatus);
          console.log('✅ Status update response:', response);

        } catch (err) {
          console.error(`❌ Failed to update status:`, err);
          // Revert on error
          event.target.value = previousValue;
          applyStatusColor(event.target, previousValue);
          event.target.dataset.previousValue = previousValue;
          ui.showError(`Failed to update status: ${err.message}`);
        }
      },

      onSearchInput: debounce((event) => {
        filterOrders(event.target.value);
      }, SEARCH_DEBOUNCE),

      onFilterChange: async () => {
        try {
          const data = await api.fetchOrders();
          state.allOrders = Array.isArray(data) ? data : [];
          const query = document.getElementById("searchInput").value;
          filterOrders(query);
        } catch (err) {
          console.error("❌ Failed to update orders:", err);
          ui.showError("Failed to update filters");
        }
      }
    };

    // Initialize search functionality
    function initializeSearch() {
      const searchInput = document.getElementById("searchInput");
      if (!searchInput) {
        console.error('Search input not found');
        return;
      }

      // Clear any existing listeners
      const newSearchInput = searchInput.cloneNode(true);
      searchInput.parentNode.replaceChild(newSearchInput, searchInput);

      // Add new listener for immediate search
      newSearchInput.addEventListener("input", (e) => {
        const query = e.target.value;
        console.log('🔍 Search input:', query);
        filterOrders(query);
      });

      // Initialize toggle listeners
      const oldOrdersToggle = document.getElementById("showOldToggle");
      const completedToggle = document.getElementById("showCompletedToggle");
      const staffFilter = document.getElementById("staffFilter");

      [oldOrdersToggle, completedToggle, staffFilter].forEach(element => {
        if (element) {
          const newElement = element.cloneNode(true);
          element.parentNode.replaceChild(newElement, element);
          newElement.addEventListener("change", async () => {
            try {
              const data = await api.fetchOrders();
              state.allOrders = Array.isArray(data) ? data : [];
              const currentQuery = document.getElementById("searchInput").value;
              filterOrders(currentQuery);
            } catch (err) {
              console.error("❌ Failed to update orders:", err);
            }
          });
        }
      });
    }

    function filterOrders(query) {
      if (!state.allOrders) {
        console.warn('No orders in state to filter');
        return;
      }

      const q = (query || '').toLowerCase().trim();
      const isSearchActive = q.length > 0;
      const staffFilter = document.getElementById("staffFilter")?.value;

      console.log(`🔍 Filtering ${state.allOrders.length} orders with query: "${q}"`);
      console.log('Current user:', state.currentUser);
      console.log('Current tab:', state.currentTab);

      // First, filter based on the current tab
      let filtered = [...state.allOrders];

      // For claimed tab, ONLY show orders claimed by current user
      if (state.currentTab === "claimed") {
        const validStaffMembers = state.staffMembers.map(staff => staff.username);
        filtered = filtered.filter(order => {
          console.log('Checking order:', order.id, {
            claimed_by: order.claimed_by,
            assigned_staff: order.assigned_staff,
            isValidStaff: validStaffMembers.includes(order.assigned_staff),
            status: order.status
          });
          return (
            order.claimed_by === state.currentUser &&
            order.assigned_staff === state.currentUser &&
            validStaffMembers.includes(order.assigned_staff) &&
            order.status?.toLowerCase() !== "completed"
          );
        });
        console.log('Filtered claimed orders:', filtered.length);
      }

      // Then apply search filter if present
      if (q) {
        filtered = filtered.filter(order => {
          const searchFields = {
            name: String(order.name || ''),
            email: String(order.email || ''),
            phone: String(order.phone || ''),
            id: String(order.id || ''),
            notes: String(order.notes || '')
          };
          const searchValues = Object.values(searchFields).map(v => v.toLowerCase());
          return searchValues.some(value => value.includes(q));
        });
      }

      // Apply staff filter if selected
      if (staffFilter) {
        filtered = filtered.filter(order => order.assigned_staff === staffFilter);
      }

      console.log(`✨ Found ${filtered.length} matching orders after all filters`);

      // Clear the grid before rendering
      const grid = document.getElementById("orderGrid");
      if (grid) {
        grid.innerHTML = "";
        if (state.currentTab === "claimed") {
          renderClaimedOrders(filtered, isSearchActive);
        } else {
          renderOrders(filtered, isSearchActive);
        }
      }
    }

    // Fix the login form handler
    document.addEventListener("DOMContentLoaded", () => {
      const loginOverlay = document.getElementById("loginOverlay");
      const loginForm = document.getElementById("loginForm");
      const loginError = document.getElementById("loginError");

      // Auto-login if remembered
      if (localStorage.getItem("rememberedUser")) {
        api.checkSession()
          .then(data => {
            state.currentUser = data.username;
            ui.hideLoginOverlay();
            
            // Initialize everything after successful auto-login
            return api.getStaffList();
          })
          .then(staffList => {
            state.staffMembers = staffList;
            initializeEventListeners();
            return loadInitialOrders();
          })
          .then(() => {
            initializeSSE();
          })
          .catch(() => {
            console.warn("Failed to auto-login");
            localStorage.removeItem("rememberedUser");
          });
      }

      loginForm.addEventListener("submit", async (e) => {
        e.preventDefault();
        loginError.style.display = "none";

        const username = document.getElementById("username").value.trim().toLowerCase();
        const password = document.getElementById("password").value.trim();
        const remember = document.getElementById("rememberMe").checked;

        try {
          await api.login(username, password, remember);

          if (remember) {
            localStorage.setItem("rememberedUser", "true");
          }

          // Get session info
          const data = await api.checkSession();
          state.currentUser = data.username;

          // Initialize staff list
          try {
            console.log('🔄 Fetching staff list...');
            const staffList = await api.getStaffList();
            state.staffMembers = staffList;

            // Populate staff filter
            const staffFilter = document.getElementById("staffFilter");
            staffFilter.innerHTML = '<option value="">All Staff</option>';
            state.staffMembers.forEach(staff => {
              const option = document.createElement("option");
              option.value = staff.username;
              option.textContent = staff.displayName;
              staffFilter.appendChild(option);
            });
          } catch (err) {
            console.error('❌ Failed to load staff list:', err);
          }

          // Hide login and initialize everything
          ui.hideLoginOverlay();
          
          // Initialize event listeners AFTER login
          setTimeout(() => {
            initializeEventListeners();
            console.log('🎯 Tab event listeners initialized');
            
            // Test if tabs are clickable
            const allTab = document.getElementById("tabAll");
            const claimedTab = document.getElementById("tabClaimed");
            console.log('🔍 Tab elements found:', { allTab: !!allTab, claimedTab: !!claimedTab });
            
            if (allTab && claimedTab) {
              console.log('✅ Tab elements have onclick handlers:', { 
                allTabHandler: typeof allTab.onclick, 
                claimedTabHandler: typeof claimedTab.onclick 
              });
            }
          }, 100);
          
          await loadInitialOrders();
          initializeSSE();

        } catch (err) {
          loginError.textContent = err.message || "Login failed. Please try again.";
          loginError.style.display = "block";
          console.error("Login failed:", err);
        }
      });
    });

    // Initialize event listeners
    function initializeEventListeners() {
      console.log('🔧 Initializing event listeners...');
      
      // Tab click handlers
      const allTab = document.getElementById("tabAll");
      const claimedTab = document.getElementById("tabClaimed");

      console.log('🔍 Found tab elements:', { 
        allTab: !!allTab, 
        claimedTab: !!claimedTab,
        allTabVisible: allTab ? getComputedStyle(allTab).display !== 'none' : false,
        claimedTabVisible: claimedTab ? getComputedStyle(claimedTab).display !== 'none' : false
      });

      if (allTab) {
        allTab.onclick = () => {
          console.log('🎯 All Orders tab clicked!');
          state.currentTab = "all";
          console.log('Switching to All Orders tab');
          ui.updateTabStyles();
          const query = document.getElementById("searchInput").value;
          filterOrders(query);
        };
        console.log('✅ All Orders tab onclick handler set');
      } else {
        console.error('❌ All Orders tab element not found!');
      }

      if (claimedTab) {
        claimedTab.onclick = () => {
          console.log('🎯 Claimed Orders tab clicked!');
          state.currentTab = "claimed";
          console.log('Switching to Claimed Orders tab');
          ui.updateTabStyles();
          const query = document.getElementById("searchInput").value;
          filterOrders(query);
        };
        console.log('✅ Claimed Orders tab onclick handler set');
      } else {
        console.error('❌ Claimed Orders tab element not found!');
      }

      // Verify that the handlers are actually set
      setTimeout(() => {
        console.log('🔍 Verifying onclick handlers after setup:', {
          allTabHandler: allTab ? typeof allTab.onclick : 'tab not found',
          claimedTabHandler: claimedTab ? typeof claimedTab.onclick : 'tab not found'
        });
      }, 50);

      // Filter listeners
      const oldOrdersToggle = document.getElementById("showOldToggle");
      const completedToggle = document.getElementById("showCompletedToggle");
      const staffFilter = document.getElementById("staffFilter");
      const searchInput = document.getElementById("searchInput");

      [oldOrdersToggle, completedToggle, staffFilter].forEach(element => {
        if (element) {
          element.onchange = handlers.onFilterChange;
        }
      });

      if (searchInput) {
        searchInput.oninput = handlers.onSearchInput;
      }

      // Window event listeners
      window.addEventListener('beforeunload', () => {
        if (window.dashboardEventSource) {
          window.dashboardEventSource.close();
        }
      });

      // Error handling for failed image loads
      document.addEventListener('error', (e) => {
        if (e.target.tagName === 'IMG') {
          e.target.style.display = 'none';
        }
      }, true);
      
      console.log('🔧 Event listeners initialization complete');
    }

    // Add back the applyStatusColor function
    function applyStatusColor(dropdown, status) {
      const normalized = status.toLowerCase().replace(/\s+/g, "-");
      dropdown.className = "status-dropdown status-" + normalized;
    }

    // Add back the autoEstimateOrder function
    async function autoEstimateOrder(order, card) {
      try {
        const files = await fetch(`/dashboard/files/${order.id}`).then((r) =>
          r.json()
        );
        if (!files.length) {
          console.log(`⏭️ Skipped ${order.id} — No STL files found.`);
          return;
        }

        const formData = new FormData();
        const fileNames = [];

        for (const fileUrl of files) {
          const response = await fetch(fileUrl);
          const blob = await response.blob();
          const filename = decodeURIComponent(fileUrl.split("/").pop());
          formData.append("stl", blob, filename);
          fileNames.push(filename);
        }

        const sseResponse = await fetch("/stl/upload", {
          method: "POST",
          headers: {
            Origin: "https://filamentbros.com",
          },
          body: formData,
        });

        const reader = sseResponse.body.getReader();
        const decoder = new TextDecoder("utf-8");
        let buffer = "";
        let totalEstimate = 0;
        let failedFiles = [];

        while (true) {
          const { value, done } = await reader.read();
          if (done) break;
          buffer += decoder.decode(value, { stream: true });

          const events = buffer.split("\n\n");
          buffer = events.pop(); // Keep last incomplete

          for (const event of events) {
            if (event.startsWith("data:")) {
              const data = JSON.parse(event.replace("data:", "").trim());
              if (data.status === "success" && data.price) {
                totalEstimate += parseFloat(data.price);
              } else if (data.status === "error") {
                failedFiles.push(data.file || "Unknown file");
              }
            }
          }
        }

        if (totalEstimate > 0) {
          await fetch("/dashboard/update-price", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              orderId: order.id,
              est_price: totalEstimate.toFixed(2),
            }),
          });
          console.log(
            `✅ Updated order ${order.id} with estimate $${totalEstimate.toFixed(2)}`
          );
        }

        if (card) {
          const priceLine = card.querySelector("p");
          if (priceLine) {
            priceLine.innerHTML = `<strong>Est. Price:</strong> $${totalEstimate.toFixed(2)}`;
          }

          if (failedFiles.length > 0) {
            const message = `⚠️ Print estimate failed for: ${failedFiles.join(", ")}`;

            // Update in database
            await fetch("/dashboard/update-notes", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({
                orderId: order.id,
                order_notes: message,
              }),
            });

            // Update UI immediately
            const notesLine = [...card.querySelectorAll("li")].find((li) =>
              li.innerHTML.includes("Staff Notes:")
            );
            if (notesLine) {
              notesLine.innerHTML = `<strong>Staff Notes:</strong> ${message}`;
            }
          }
        }
      } catch (err) {
        console.error(`❌ Failed to auto-estimate for order ${order.id}:`, err);
      }
    }

    // Add back missing essential functions
    
    // Add necessary CSS animations
    const style = document.createElement('style');
    style.textContent = `
      @keyframes slideIn {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
      @keyframes slideOut {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(100%); opacity: 0; }
      }
    `;
    document.head.appendChild(style);

    // Add error handling wrapper for async functions
    const withErrorHandling = (fn) => async (...args) => {
      try {
        return await fn(...args);
      } catch (err) {
        console.error('❌ Error:', err);
        ui.showError(err.message || 'An error occurred');
        throw err;
      }
    };

    // Wrap API calls with error handling
    Object.keys(api).forEach(key => {
      if (typeof api[key] === 'function') {
        api[key] = withErrorHandling(api[key]);
      }
    });

    // Add back the updateOrderCard function
    function updateOrderCard(card, order) {
      // Update status dropdown
      const statusDropdown = card.querySelector('.status-dropdown');
      if (statusDropdown) {
        statusDropdown.value = order.status || 'pending';
        applyStatusColor(statusDropdown, order.status || 'pending');
      }

      // Update price
      const priceElement = card.querySelector('p');
      if (priceElement) {
        priceElement.innerHTML = `<strong>Est. Price:</strong> ${order.est_price ? `$${order.est_price.toFixed(2)}` : '—'}`;
      }
    }

    // Create staff assignment dropdown
    function createStaffDropdown(order) {
      const staffSelect = document.createElement("select");
      staffSelect.className = "staff-dropdown";
      staffSelect.style.padding = "0.4rem";
      staffSelect.style.borderRadius = "0.3rem";
      staffSelect.style.border = "1px solid #ccc";
      staffSelect.style.marginLeft = "0.5rem";

      // Add empty option
      const emptyOption = document.createElement("option");
      emptyOption.value = "";
      emptyOption.textContent = "-- Select Staff --";
      staffSelect.appendChild(emptyOption);

      // Add staff options
      state.staffMembers.forEach(staff => {
        const option = document.createElement("option");
        option.value = staff.username;
        option.textContent = staff.displayName;
        if (staff.username === order.assigned_staff) {
          option.selected = true;
        }
        staffSelect.appendChild(option);
      });

      // Handle staff assignment
      staffSelect.addEventListener("change", async () => {
        try {
          const newStaff = staffSelect.value;
          const response = await api.assignStaff(order.id, newStaff);
          order.assigned_staff = newStaff;
        } catch (err) {
          console.error(`❌ Failed to assign staff for order ${order.id}:`, err);
          staffSelect.value = order.assigned_staff || ""; // Revert on error
          ui.showError(`Failed to assign staff: ${err.message}`);
        }
      });

      return staffSelect;
    }

    // Add back the renderOrders function (complete version)
    async function renderOrders(orders, expandDetails = false, container = null) {
      const grid = container || document.getElementById("orderGrid");
      if (!container) grid.innerHTML = "";

      for (const order of orders) {
        const card = document.createElement("div");
        card.className = "card";
        card.dataset.orderId = order.id;

        const heading = document.createElement("h2");
        heading.textContent = order.name || "Unnamed Order";
        card.appendChild(heading);

        const statusOptions = [
          "pending",
          "pre print",
          "printing",
          "printing pay later",
          "completed",
        ];
        const currentStatus = (order.status || "pending").toLowerCase();

        const statusDropdown = document.createElement("select");
        statusDropdown.className = "status-dropdown";
        statusDropdown.dataset.previousValue = currentStatus;
        applyStatusColor(statusDropdown, currentStatus);

        statusOptions.forEach((status) => {
          const option = document.createElement("option");
          option.value = status;
          option.textContent = status
            .split(" ")
            .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
            .join(" ");
          if (status.toLowerCase() === currentStatus.toLowerCase()) {
            option.selected = true;
          }
          statusDropdown.appendChild(option);
        });

        // Single event handler for status changes
        statusDropdown.addEventListener("change", async () => {
          const newStatus = statusDropdown.value;
          const previousValue = statusDropdown.dataset.previousValue;

          try {
            // Update UI immediately
            applyStatusColor(statusDropdown, newStatus);
            statusDropdown.dataset.previousValue = newStatus;

            console.log(`🔄 Initiating status change for ${order.id}: ${newStatus}`);

            // Send HTTP request
            const response = await api.updateStatus(order.id, newStatus);
            console.log('✅ Status update response:', response);

          } catch (err) {
            console.error(`❌ Failed to update status:`, err);
            // Revert on error
            statusDropdown.value = previousValue;
            applyStatusColor(statusDropdown, previousValue);
            statusDropdown.dataset.previousValue = previousValue;
            ui.showError(`Failed to update status: ${err.message}`);
          }
        });

        const statusWrapper = document.createElement("div");
        statusWrapper.style.marginTop = "0.5rem";
        statusWrapper.appendChild(statusDropdown);
        card.appendChild(statusWrapper);

        // Show estimated price right under heading
        const price = document.createElement("p");
        price.innerHTML = `<strong>Est. Price:</strong> ${order.est_price ? `$${order.est_price.toFixed(2)}` : "—"}`;
        card.appendChild(price);

        const toggleBtn = document.createElement("button");
        toggleBtn.className = "details-toggle";
        toggleBtn.textContent = "Show Details ▼";
        card.appendChild(toggleBtn);

        const detailsSection = document.createElement("div");
        detailsSection.className = "details-section";
        card.appendChild(detailsSection);

        const idLine = document.createElement("div");
        idLine.className = "order-id";
        idLine.textContent = `Order ID: ${order.id}`;
        card.appendChild(idLine);

        const table = document.createElement("table");
        table.className = "details-table";
        const submittedDate = new Date(order.submitted_at);
        const formattedDate = submittedDate.toLocaleString("en-US", {
          year: "numeric",
          month: "short",
          day: "numeric",
          hour: "2-digit",
          minute: "2-digit",
          hour12: true,
        });

        // Create staff assignment dropdown
        const staffSelect = document.createElement("select");
        staffSelect.className = "staff-dropdown";
        staffSelect.style.padding = "0.4rem";
        staffSelect.style.borderRadius = "0.3rem";
        staffSelect.style.border = "1px solid #ccc";
        staffSelect.style.marginLeft = "0.5rem";

        // Add empty option
        const emptyOption = document.createElement("option");
        emptyOption.value = "";
        emptyOption.textContent = "-- Select Staff --";
        staffSelect.appendChild(emptyOption);

        // Add staff options
        state.staffMembers.forEach(staff => {
          const option = document.createElement("option");
          option.value = staff.username;
          option.textContent = staff.displayName;
          if (staff.username === order.assigned_staff) {
            option.selected = true;
          }
          staffSelect.appendChild(option);
        });

        // Handle staff assignment
        staffSelect.addEventListener("change", async () => {
          try {
            const newStaff = staffSelect.value;
            const response = await api.assignStaff(order.id, newStaff);
            order.assigned_staff = newStaff;
          } catch (err) {
            console.error(`❌ Failed to assign staff for order ${order.id}:`, err);
            staffSelect.value = order.assigned_staff || ""; // Revert on error
            ui.showError(`Failed to assign staff: ${err.message}`);
          }
        });

        [
          ["Email", order.email],
          ["Phone", order.phone],
          ["Staff", order.assigned_staff || "—"],
          ["Customer Notes", order.notes || "—"],
          ["Staff Notes", order.order_notes || "—"],
          ["Submitted At", formattedDate],
          ["Last Updated By", order.updated_by || "—"]
        ].forEach(([label, value]) => {
          const row = document.createElement("tr");
          if (label === "Staff") {
            row.innerHTML = `<td>${label}:</td><td></td>`;
            row.cells[1].appendChild(staffSelect);
          } else {
            row.innerHTML = `<td>${label}:</td><td>${value}</td>`;
          }
          table.appendChild(row);
        });

        detailsSection.appendChild(table);

        toggleBtn.onclick = () => {
          const visible = detailsSection.classList.toggle("visible");
          toggleBtn.textContent = visible ? "Hide ▲" : "Show Details ▼";
        };

        // Expand by default if search is active
        if (expandDetails) {
          detailsSection.classList.add("visible");
          toggleBtn.textContent = "Hide ▲";
        }

        fetch(`/dashboard/files/${order.id}`)
          .then((res) => res.json())
          .then((files) => {
            if (files.length > 0) {
              const stlTitle = document.createElement("p");
              stlTitle.className = "stl-header";
              stlTitle.textContent = "STL Files:";
              detailsSection.appendChild(stlTitle);

              const list = document.createElement("ul");
              list.className = "stl-list";

              files.forEach((fileUrl) => {
                const fullFilename = decodeURIComponent(fileUrl.split("/").pop());
                const downloadUrl = `/dashboard/fileserve/${encodeURIComponent(fullFilename)}`;
                const filename = fullFilename.replace(/^order[_-]?[a-zA-Z0-9]+[_-]/i, "");

                const li = document.createElement("li");
                li.innerHTML = `
                  <a href="${downloadUrl}" title="${filename}" class="stl-link" download target="_blank">
                    ${filename}
                  </a>`;
                list.appendChild(li);
              });

              detailsSection.appendChild(list);

              if (files.length > 0) {
                const downloadAll = document.createElement("a");
                downloadAll.href = `/dashboard/download-all/${order.id}`;
                downloadAll.className = "download-all-btn";
                downloadAll.textContent = "📦 Download All";
                detailsSection.appendChild(downloadAll);
              }
            }

            const isClaimed = order.claimed_by !== null;
            const isCompleted = order.status?.toLowerCase() === "completed";
            const isClaimedByCurrentUser = order.claimed_by === state.currentUser;

            // Add unclaim button if the order is claimed by current user (regardless of tab)
            if (isClaimedByCurrentUser && !isCompleted) {
              const unclaimBtn = document.createElement("button");
              unclaimBtn.textContent = "Unclaim";
              unclaimBtn.style.backgroundColor = "#ccc";
              unclaimBtn.style.border = "none";
              unclaimBtn.style.color = "#333";
              unclaimBtn.style.padding = "0.5rem 1rem";
              unclaimBtn.style.borderRadius = "0.5rem";
              unclaimBtn.style.marginTop = "0.5rem";
              unclaimBtn.style.cursor = "pointer";

              unclaimBtn.addEventListener("click", async () => {
                try {
                  // Update UI immediately
                  unclaimBtn.textContent = "Unclaiming...";
                  unclaimBtn.disabled = true;
                  unclaimBtn.style.cursor = "not-allowed";

                  const response = await api.unclaimOrder(order.id);
                  
                  // Update the order object with the response data
                  if (response && response.order) {
                    Object.assign(order, response.order);
                  } else {
                    order.claimed_by = null;
                    order.assigned_staff = null;
                  }
                  
                  // If in claimed tab, smoothly remove the card
                  if (state.currentTab === "claimed") {
                    const card = unclaimBtn.closest('.card');
                    if (card) {
                      card.style.transition = "all 0.3s ease";
                      card.style.opacity = "0";
                      card.style.transform = "scale(0.9)";
                      setTimeout(() => card.remove(), 300);
                    }
                  }
                  
                  // Update the order in global state
                  const index = state.allOrders.findIndex(o => o.id === order.id);
                  if (index !== -1) {
                    state.allOrders[index] = { ...order };
                  }
                  
                } catch (err) {
                  console.error(`Failed to unclaim order ${order.id}:`, err);
                  ui.showError(err.message || "Failed to unclaim order");
                  
                  // Revert UI on error
                  unclaimBtn.textContent = "Unclaim";
                  unclaimBtn.disabled = false;
                  unclaimBtn.style.cursor = "pointer";
                }
              });

              card.appendChild(unclaimBtn);
            }

            // Only show claim button in "All Orders" tab
            if (state.currentTab === "all") {
              if (isCompleted) {
                const completedLabel = document.createElement("button");
                completedLabel.textContent = "Completed";
                completedLabel.disabled = true;
                completedLabel.style.backgroundColor = "#999";
                completedLabel.style.border = "none";
                completedLabel.style.color = "#666";
                completedLabel.style.padding = "0.5rem 1rem";
                completedLabel.style.borderRadius = "0.5rem";
                completedLabel.style.marginTop = "0.5rem";
                completedLabel.style.cursor = "not-allowed";
                card.appendChild(completedLabel);
              } else if (!isClaimedByCurrentUser) {
                const claimBtn = document.createElement("button");
                claimBtn.textContent = isClaimed ? `Claimed by ${order.claimed_by}` : "Claim Order";
                claimBtn.disabled = isClaimed;
                claimBtn.style.backgroundColor = isClaimed ? '#999' : '#ccc';
                claimBtn.style.border = "none";
                claimBtn.style.color = "#333";
                claimBtn.style.padding = "0.5rem 1rem";
                claimBtn.style.borderRadius = "0.5rem";
                claimBtn.style.marginTop = "0.5rem";
                claimBtn.style.cursor = isClaimed ? "not-allowed" : "pointer";

                if (!isClaimed) {
                  claimBtn.addEventListener("click", async () => {
                    try {
                      // Update UI immediately
                      claimBtn.textContent = "Claiming...";
                      claimBtn.disabled = true;
                      claimBtn.style.backgroundColor = "#999";
                      claimBtn.style.cursor = "not-allowed";

                      const response = await api.claimOrder(order.id);
                      
                      // Update the order object with the response data
                      if (response && response.order) {
                        Object.assign(order, response.order);
                        
                        // Create and show unclaim button immediately
                        const unclaimBtn = document.createElement('button');
                        unclaimBtn.textContent = 'Unclaim';
                        unclaimBtn.style.cssText = `
                          background-color: #ccc;
                          border: none;
                          color: #333;
                          padding: 0.5rem 1rem;
                          border-radius: 0.5rem;
                          margin-top: 0.5rem;
                          cursor: pointer;
                        `;

                        // Add unclaim functionality
                        unclaimBtn.addEventListener('click', async () => {
                          try {
                            unclaimBtn.textContent = 'Unclaiming...';
                            unclaimBtn.disabled = true;
                            unclaimBtn.style.cursor = 'not-allowed';

                            const response = await api.unclaimOrder(order.id);
                            
                            if (state.currentTab === "claimed") {
                              const card = unclaimBtn.closest('.card');
                              if (card) {
                                card.style.transition = "all 0.3s ease";
                                card.style.opacity = "0";
                                card.style.transform = "scale(0.9)";
                                setTimeout(() => card.remove(), 300);
                              }
                            }
                          } catch (err) {
                            console.error(`Failed to unclaim order ${order.id}:`, err);
                            ui.showError(err.message || "Failed to unclaim order");
                            unclaimBtn.textContent = 'Unclaim';
                            unclaimBtn.disabled = false;
                            unclaimBtn.style.cursor = 'pointer';
                          }
                        });

                        claimBtn.replaceWith(unclaimBtn);
                      }
                      
                    } catch (err) {
                      console.error(`Failed to claim order ${order.id}:`, err);
                      ui.showError(err.message || "Failed to claim order");
                      
                      // Revert UI on error
                      claimBtn.textContent = "Claim Order";
                      claimBtn.disabled = false;
                      claimBtn.style.backgroundColor = "#ccc";
                      claimBtn.style.cursor = "pointer";
                    }
                  });
                }

                card.appendChild(claimBtn);
              }
            }
          })
          .catch((err) => {
            console.error(`❌ Failed to load STL files for ${order.id}`, err);
          });

        grid.appendChild(card);

        if (
          (order.est_price == null || order.est_price === 0) &&
          !(order.order_notes && order.order_notes.includes("Print estimate failed"))
        ) {
          autoEstimateOrder(order, card);
        }
      }
    }

    // Add back the renderClaimedOrders function
    async function renderClaimedOrders(orders, expandDetails = false) {
      const grid = document.getElementById("orderGrid");
      grid.innerHTML = "";

      // Filter for orders that are properly claimed by the current user
      const validStaffMembers = state.staffMembers.map(staff => staff.username);
      const claimedOrders = orders.filter(order =>
        order.claimed_by === state.currentUser &&
        order.assigned_staff === state.currentUser &&
        validStaffMembers.includes(order.assigned_staff) &&
        order.status?.toLowerCase() !== "completed"
      );

      console.log(`📋 Rendering ${claimedOrders.length} claimed orders for user ${state.currentUser}`);

      // Use the existing renderOrders function to render the filtered orders
      await renderOrders(claimedOrders, expandDetails, grid);
    }

    // Add back the initializeSSE function
    function initializeSSE() {
      let retryCount = 0;
      const maxRetries = 5;
      const retryDelay = 1000;

      function connect() {
        const eventSource = new EventSource('/dashboard/updates', { withCredentials: true });

        eventSource.onopen = () => {
          console.log('✅ SSE connection established');
          retryCount = 0;
        };

        eventSource.onerror = (error) => {
          console.error('❌ SSE connection error:', error);
          eventSource.close();

          if (retryCount < maxRetries) {
            retryCount++;
            setTimeout(connect, retryDelay * retryCount);
          } else {
            console.error('❌ Max SSE reconnection attempts reached');
            ui.showError('Lost connection to server. Please refresh the page.');
          }
        };

        // Store the eventSource in window for cleanup
        window.dashboardEventSource = eventSource;

        // Handle order updates
        eventSource.addEventListener('orderUpdate', (e) => {
          try {
            const update = JSON.parse(e.data);
            console.log('📦 Received order update:', update);
            handleOrderUpdate(update.order);
          } catch (err) {
            console.error('❌ Failed to process order update:', err);
            ui.showError('Failed to process update');
          }
        });

        return eventSource;
      }

      connect();
    }

    // Start the app
    async function initialize() {
      try {
        // Check session first
        const sessionData = await api.checkSession();
        if (sessionData.username) {
          state.currentUser = sessionData.username;
          ui.hideLoginOverlay();
          
          // Get staff list
          const staffList = await api.getStaffList();
          state.staffMembers = staffList;
          
          // Initialize UI components
          setTimeout(() => {
            initializeEventListeners();
            console.log('🎯 Dashboard initialized with tab listeners');
          }, 100);
          
          await loadInitialOrders();
          initializeSSE();
        } else {
          ui.showLoginOverlay();
        }
      } catch (err) {
        console.error('Failed to initialize:', err);
        ui.showLoginOverlay();
      }
    }

    // Start the app
    document.addEventListener("DOMContentLoaded", initialize);
  </script>

  <div id="loginOverlay" class="login-overlay">
    <div class="login-box">
      <h2>FilamentBros Login</h2>
      <form id="loginForm">
        <input type="text" id="username" placeholder="Username" required />
        <input type="password" id="password" placeholder="Password" required />
        <label class="remember-line">
          <input type="checkbox" id="rememberMe" />
          Remember Me
        </label>
        <button type="submit">Login</button>
        <p id="loginError" style="color: red; display: none; font-size: 0.85rem"></p>
      </form>
    </div>
  </div>
</body>

</html>